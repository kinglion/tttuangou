<?php

//Copyright © 2013-2020 深圳市木浪科技有限公司. All Rights Reserved.,2013/09/13
error_reporting(0);
date_default_timezone_set('Asia/Shanghai');
define('MAX_ONE_FILE_SIZE',10000000);
define('MAX_ONCE_ZIP_SIZE',20000000);

$g_tasks = array() ;
$g_current_progress_file = '';
$g_finished = false;
$g_exec_complete = false;
$g_timeout_seconds = 15+time();
$g_log_file = 'dbfen.log';
$debug = FALSE;

//请修改为你网站或手机后台服务对应的参数
$db_info['db_host'] = 'db316.72dns.net';
$db_info['db_port'] = '3306';
$db_info['db_name'] = 'db_tl0754com';
$db_info['db_user'] = 'tl0754com';
$db_info['db_passwd'] = 'rlbc7o';
$backup_info['tmpDir'] = '';
$backup_info['folders'] = array('/');
$backup_info['encrypt_key'] = 'uod6zsmsvyx4Pp8n';


//以下由多备份自动生成的,不能修改

$backup_type  = intval($_POST['bt']);
$task_id = intval($_POST['tid']);
$user_id = intval($_POST['uid']);
$app_key  = $_POST['apk'];
$app_secret  = $_POST['aps'];
$dbfen_key  = $_POST['dk'];
$action_type  = $_POST['at'];

$dbfen_ip = '';
if( isset($_SERVER['HTTP_X_FORWARDED_FOR']) ){
   $dbfen_ip=$_SERVER['HTTP_X_FORWARDED_FOR'];
 }else if( isset($_SERVER['HTTP_CLIENT_IP']) ){
   $dbfen_ip=$_SERVER['HTTP_CLIENT_IP'];
 }else{
   $dbfen_ip=$_SERVER['REMOTE_ADDR'];
 }

$backup_info['backup_type'] = $backup_type;
$backup_info['action_type'] = $action_type;
$backup_info['app_key'] = '312246c286796d1e7cab530670ab30ed';
$backup_info['app_secret'] = 'CBl2uNkfBYYQDW52q0Z6ta73i7McUuIW';
$backup_info['dbfen_key'] = 'DBFEN@KEYoAjR9RkKzKNyzra5uc0ws39vzprzzbme';
$backup_info['dbfen_ip'] = array('webmgr'=>'115.28.36.60','db'=>'113.108.221.222','fs'=>'');
$backup_info['task_id'] =  $task_id;
$backup_info['user_id'] =  $user_id;
 $tmp_path = md5($backup_info['encrypt_key'] . $backup_info['app_key'] . $backup_info['app_secret']); $tmp_path = md5($tmp_path); define( 'PCLZIP_TEMPORARY_DIR', $tmp_path . '/ziptmp/' ); if (!class_exists('ZipArchive') OR !extension_loaded('zip') ) { if (!defined('PCLZIP_READ_BLOCK_SIZE')) { define( 'PCLZIP_READ_BLOCK_SIZE', 2048 ); } if (!defined('PCLZIP_SEPARATOR')) { define( 'PCLZIP_SEPARATOR', ',' ); } if (!defined('PCLZIP_ERROR_EXTERNAL')) { define( 'PCLZIP_ERROR_EXTERNAL', 0 ); } if (!defined('PCLZIP_TEMPORARY_DIR')) { define( 'PCLZIP_TEMPORARY_DIR', '' ); } if (!defined('PCLZIP_TEMPORARY_FILE_RATIO')) { define( 'PCLZIP_TEMPORARY_FILE_RATIO', 0.47 ); } define( 'PCLZIP_OPT_ADD_PATH', 77002 ); define( 'PCLZIP_OPT_REMOVE_PATH', 77003 ); define( 'PCLZIP_OPT_REMOVE_ALL_PATH', 77004 ); define( 'PCLZIP_OPT_NO_COMPRESSION', 77007 ); define( 'PCLZIP_OPT_COMMENT', 77012 ); define( 'PCLZIP_OPT_ADD_COMMENT', 77013 ); define( 'PCLZIP_OPT_PREPEND_COMMENT', 77014 ); define( 'PCLZIP_OPT_TEMP_FILE_THRESHOLD', 77020 ); define( 'PCLZIP_OPT_TEMP_FILE_ON', 77021 ); define( 'PCLZIP_OPT_TEMP_FILE_OFF', 77022 ); define( 'PCLZIP_ATT_FILE_NAME', 79001 ); define( 'PCLZIP_ATT_FILE_NEW_SHORT_NAME', 79002 ); define( 'PCLZIP_ATT_FILE_NEW_FULL_NAME', 79003 ); define( 'PCLZIP_ATT_FILE_MTIME', 79004 ); define( 'PCLZIP_ATT_FILE_CONTENT', 79005 ); define( 'PCLZIP_ATT_FILE_COMMENT', 79006 ); define( 'PCLZIP_CB_PRE_ADD', 78003 ); define( 'PCLZIP_CB_POST_ADD', 78004 ); class ZipArchive extends PclZip { const CREATE = 0; const OVERWRITE = 0; public function addFile($args) { return $this->add($args); } public function addEmptyDir($args) { return $this->add($args); } public function close() { return TRUE; } } } if(!class_exists('PDO')) { abstract class PDO { const PARAM_BOOL = 5; const PARAM_NULL = 0; const PARAM_INT = 1; const PARAM_STR = 2; const PARAM_LOB = 3; const PARAM_STMT = 4; const PARAM_INPUT_OUTPUT = -2147483648; const FETCH_LAZY = 1; const FETCH_ASSOC = 2; const FETCH_NAMED = 11; const FETCH_NUM = 3; const FETCH_BOTH = 4; const FETCH_OBJ = 5; const FETCH_BOUND = 6; const FETCH_COLUMN = 7; const FETCH_CLASS = 8; const FETCH_INTO = 9; const FETCH_FUNC = 10; const FETCH_GROUP = 65536; const FETCH_UNIQUE = 196608; const FETCH_KEY_PAIR = 12; const FETCH_CLASSTYPE = 262144; const FETCH_SERIALIZE = 524288; const FETCH_PROPS_LATE = 1048576; const ATTR_AUTOCOMMIT = 0; const ATTR_PREFETCH = 1; const ATTR_TIMEOUT = 2; const ATTR_ERRMODE = 3; const ATTR_SERVER_VERSION = 4; const ATTR_CLIENT_VERSION = 5; const ATTR_SERVER_INFO = 6; const ATTR_CONNECTION_STATUS = 7; const ATTR_CASE = 8; const ATTR_CURSOR_NAME = 9; const ATTR_CURSOR = 10; const ATTR_DRIVER_NAME = 16; const ATTR_ORACLE_NULLS = 11; const ATTR_PERSISTENT = 12; const ATTR_STATEMENT_CLASS = 13; const ATTR_FETCH_CATALOG_NAMES = 15; const ATTR_FETCH_TABLE_NAMES = 14; const ATTR_STRINGIFY_FETCHES = 17; const ATTR_MAX_COLUMN_LEN = 18; const ATTR_DEFAULT_FETCH_MODE = 19; const ATTR_EMULATE_PREPARES = 20; const ERRMODE_SILENT = 0; const ERRMODE_WARNING = 1; const ERRMODE_EXCEPTION = 2; const CASE_NATURAL = 0; const CASE_LOWER = 2; const CASE_UPPER = 1; const NULL_NATURAL = 0; const NULL_EMPTY_STRING = 1; const NULL_TO_STRING = 2; const FETCH_ORI_NEXT = 0; const FETCH_ORI_PRIOR = 1; const FETCH_ORI_FIRST = 2; const FETCH_ORI_LAST = 3; const FETCH_ORI_ABS = 4; const FETCH_ORI_REL = 5; const CURSOR_FWDONLY = 0; const CURSOR_SCROLL = 1; const ERR_NONE = '00000'; const PARAM_EVT_ALLOC = 0; const PARAM_EVT_FREE = 1; const PARAM_EVT_EXEC_PRE = 2; const PARAM_EVT_EXEC_POST = 3; const PARAM_EVT_FETCH_PRE = 4; const PARAM_EVT_FETCH_POST = 5; const PARAM_EVT_NORMALIZE = 6; } class PDOException extends Exception { public $errorInfo = null; protected $message; protected $code; } abstract class PDOStatement { abstract public function bindColumn($column, &$param, $type = 0, $maxlen = 0, $driver_options = null); abstract public function bindParam($parameter, &$variable, $data_type = 0, $length = 0, $driver_options = null); abstract public function bindValue($parameter, $value, $data_type = 0); abstract public function closeCursor(); abstract public function columnCount(); abstract public function errorCode(); abstract public function errorInfo(); abstract public function execute($input_parameters = array()); abstract public function fetch($fetch_style = 0, $cursor_orientation = 0, $cursor_offset = 0); abstract public function fetchAll($fetch_style = 0, $column_index = 0, $ctor_args = array()); abstract public function fetchColumn($column_number = 0); abstract public function fetchObject($class_name = '', $ctor_args = array()); abstract public function getAttribute($attribute); abstract public function getColumnMeta($column); abstract public function nextRowset(); abstract public function rowCount(); abstract public function setAttribute($attribute, $value); abstract public function setFetchMode($mode, $param = '', $ctorargs = array()); } } abstract class dbf_base { const MYSQL_ATTR_USE_BUFFERED_QUERY = 1000; const MYSQL_ATTR_LOCAL_INFILE = 1001; const MYSQL_ATTR_INIT_COMMAND = 1002; const MYSQL_ATTR_READ_DEFAULT_FILE = 1003; const MYSQL_ATTR_READ_DEFAULT_GROUP = 1004; const MYSQL_ATTR_MAX_BUFFER_SIZE = 1005; const MYSQL_ATTR_DIRECT_QUERY = 1006; public $driver_options = array ( PDO::ATTR_AUTOCOMMIT => 0, PDO::ATTR_PREFETCH => 0, PDO::ATTR_TIMEOUT => false, PDO::ATTR_ERRMODE => PDO::ERRMODE_SILENT, PDO::ATTR_CASE => PDO::CASE_NATURAL, PDO::ATTR_CURSOR_NAME => '', PDO::ATTR_CURSOR => PDO::CURSOR_FWDONLY, PDO::ATTR_DRIVER_NAME => '', PDO::ATTR_ORACLE_NULLS => PDO::NULL_NATURAL, PDO::ATTR_PERSISTENT => false, PDO::ATTR_STATEMENT_CLASS => array(), PDO::ATTR_FETCH_CATALOG_NAMES => false, PDO::ATTR_FETCH_TABLE_NAMES => false, PDO::ATTR_STRINGIFY_FETCHES => false, PDO::ATTR_MAX_COLUMN_LEN => 0, PDO::ATTR_DEFAULT_FETCH_MODE => PDO::FETCH_BOTH, PDO::ATTR_EMULATE_PREPARES => 1, ); protected $dsn; protected $link; protected $in_transaction = false; protected $driver_param_type = -1; protected $driver_quote_type = 0; protected $prepared; private $last_error = array(''); public function __construct(&$dsn, &$username, &$password, &$driver_options) { $this->driver_options[PDO::ATTR_DRIVER_NAME] = $driver_options[PDO::ATTR_DRIVER_NAME]; unset($driver_options[PDO::ATTR_DRIVER_NAME]); $this->set_attributes(array(PDO::ATTR_ERRMODE), $driver_options); $this->dsn = &$dsn; $this->connect($username, $password, $driver_options); if(!isset($driver_options[PDO::ATTR_AUTOCOMMIT])) $driver_options[PDO::ATTR_AUTOCOMMIT] = 1; foreach($driver_options as $attr => &$value) { $this->setAttribute($attr, $value); } } public function __destruct() { $this->close(); } public function beginTransaction() { if($this->in_transaction) { throw new PDOException('There is already an active transaction'); } $this->driver_options[PDO::ATTR_AUTOCOMMIT] = $this->getAttribute(PDO::ATTR_AUTOCOMMIT); $this->setAttribute(PDO::ATTR_AUTOCOMMIT, 0); $this->in_transaction = true; return true; } public function commit() { if(!$this->in_transaction) { throw new PDOException('There is no active transaction'); } $this->in_transaction = false; return true; } public function errorCode() { return $this->last_error[0]; } public function errorInfo() { return $this->last_error; } abstract public function exec(&$statement); public function getAttribute($attribute, &$source = null, $func = 'PDO::getAttribute', &$last_error = null) { if($source == null) $source =& $this->driver_options; if(array_key_exists($attribute, $source)) { return $source[$attribute]; } $this->set_error(0, 'Driver does not support this function: driver does not support that attribute', 'IM001', PDO::ERRMODE_WARNING, $func, $last_error); if($last_error !== null) $last_error[1] = -1; else $this->last_error[1] = -1; return false; } abstract public function lastInsertId($name = ''); public function prepare(&$statement, &$options) { if(!$statement || !is_array($options)) return false; $driver_options = $this->driver_options; foreach($options as $k => $v) { if(!$this->setAttribute($k, $v, $driver_options, 'PDO::prepare')) { return false; } } switch($this->driver_quote_type) { case 1: $params_regex = '/(\'[^\']*(?:\'\'[^\']*)*\')|("[^"\\\\]*(?:\\\\.[^"\\\\]*)*")|([^:])(\\?|:[A-Za-z0-9_\-]+)/'; break; case 0: default: $params_regex = '/(\'[^\'\\\\]*(?:\\\\.[^\'\\\\]*)*\')|("[^"\\\\]*(?:\\\\.[^"\\\\]*)*")|([^:])(\\?|:[A-Za-z0-9_\-]+)/'; break; } $result = preg_split($params_regex, $statement, -1, PREG_SPLIT_DELIM_CAPTURE|PREG_SPLIT_NO_EMPTY); $param_type = $this->driver_param_type; $has_named = false; $has_anon = false; $warn_text = 'Invalid parameter number: mixed named and positional parameters'; $chunks_num = 0; $param_num = 0; $params_info = array(); $named_params = array(); foreach($result as &$chunk) { switch($chunk[0]) { case ':': if($has_anon) { $this->set_error(0, $warn_text, 'HY093', PDO::ERRMODE_WARNING, 'prepare'); return false; } if(isset($named_params[$chunk])) { $named_params[$chunk]++; $chunk .= $named_params[$chunk]; } else { $named_params[$chunk] = 1; } $has_named = true; $param_num++; switch($param_type) { case -1: $params_info[$chunk] = $chunks_num; break; case 1: $key = $chunk; $chunk = str_replace('-', '__', $chunk); $params_info[$key] = $chunk; break; case 2: $params_info[$chunk] = $param_num; $chunk = '$' . $param_num; break; case 0: $params_info[$chunk] = $param_num; $chunk = '?'; break; } break; case '?': if($has_named) { $this->set_error(0, $warn_text, 'HY093', PDO::ERRMODE_WARNING, 'prepare'); return false; } $has_anon = true; $param_num++; switch($param_type) { case -1: $params_info[$param_num] = $chunks_num; break; case 1: $params_info[$param_num] = ':p' . $param_num; $chunk = $params_info[$param_num]; break; case 2: $params_info[$param_num] = $param_num; $chunk = '$' . $param_num; break; case 0: $params_info[$param_num] = $param_num; break; } break; } $chunks_num++; } if($param_type == -1) { $this->prepared =& $result; } else { $this->prepared = implode('', $result); } $st = dbf_base_statement::_new_instance($driver_options[PDO::ATTR_STATEMENT_CLASS], $statement); $st->_setup($this->link, $this, $driver_options, $this->prepared, $params_info); return $st; } abstract public function quote(&$string, $parameter_type = -1); public function rollBack() { if(!$this->in_transaction) { throw new PDOException('There is no active transaction'); } $this->in_transaction = false; return true; } public function nextRowset() { return false; } public function setAttribute($attribute, $value, &$source = null, $func = 'PDO::setAttribute', &$last_error = null) { if($source == null) $source =& $this->driver_options; switch($attribute) { case PDO::ATTR_DRIVER_NAME: case PDO::ATTR_CLIENT_VERSION: case PDO::ATTR_SERVER_INFO: case PDO::ATTR_SERVER_VERSION: return false; break; } if(isset($source[$attribute])) { switch($attribute) { case PDO::ATTR_STATEMENT_CLASS: if($value === null) { $value = array(get_class($this) . '_statement'); } else if(!$this->check_attr_statement_class($value, $func)) { return false; } break; case PDO::ATTR_CASE: switch($value) { case PDO::CASE_LOWER: case PDO::CASE_NATURAL: case PDO::CASE_UPPER: break; default: return false; break; } break; case PDO::ATTR_ERRMODE: switch($value) { case PDO::ERRMODE_SILENT: case PDO::ERRMODE_WARNING: case PDO::ERRMODE_EXCEPTION: break; default: return false; break; } break; case PDO::ATTR_ORACLE_NULLS: switch($value) { case PDO::NULL_NATURAL: case PDO::NULL_EMPTY_STRING: case PDO::NULL_TO_STRING: break; default: return false; break; } break; case PDO::ATTR_DEFAULT_FETCH_MODE: switch($value) { case PDO::FETCH_LAZY: case PDO::FETCH_ASSOC: case PDO::FETCH_NAMED: case PDO::FETCH_NUM: case PDO::FETCH_BOTH: case PDO::FETCH_OBJ: case PDO::FETCH_BOUND: case PDO::FETCH_COLUMN: case PDO::FETCH_INTO: case PDO::FETCH_FUNC: case PDO::FETCH_GROUP: case PDO::FETCH_UNIQUE: case PDO::FETCH_KEY_PAIR: case PDO::FETCH_CLASS: case PDO::FETCH_CLASSTYPE: case PDO::FETCH_SERIALIZE: break; default: return false; break; } break; } $source[$attribute] = $value; return true; } $this->set_error(0, 'Driver does not support this function: driver does not support that attribute', 'IM001', PDO::ERRMODE_WARNING, $func, $last_error); if($last_error !== null) $last_error[1] = -1; else $this->last_error[1] = -1; return false; } abstract public function set_driver_error($state = null, $mode = PDO::ERRMODE_SILENT, $func = ''); public function set_error($code, $message, $state = 'HY000', $mode = PDO::ERRMODE_SILENT, $func = '', &$last_error = null) { if($last_error == null) $last_error =& $this->last_error; $last_error = array($state, $code, $message); $action = ($mode >= $this->driver_options[PDO::ATTR_ERRMODE]) ? $mode : $this->driver_options[PDO::ATTR_ERRMODE]; switch($action) { case PDO::ERRMODE_EXCEPTION: $e = new PDOException($this->get_error_str($code, $message, $state), $code); $e->errorInfo = $last_error; throw $e; break; case PDO::ERRMODE_WARNING: trigger_error($this->get_error_str($code, $message, $state, $func), E_USER_WARNING); break; case PDO::ERRMODE_SILENT: default: break; } } public function set_error_info($info) { $this->last_error = $info; } public function clear_error(&$last_error = null) { if($last_error == null) $last_error =& $this->last_error; $last_error = array(PDO::ERR_NONE, '', ''); } public function filter_result(&$value, $stringify, $nulls) { if(is_int($value) || is_float($value)) { if($stringify) $value = (string)$value; } else { switch($nulls) { case PDO::NULL_EMPTY_STRING: if($value === '') $value = null; break; case PDO::NULL_TO_STRING: if($value === null) $value = ''; break; } } } abstract protected function connect(&$username, &$password, &$driver_options); abstract protected function disconnect(); protected function set_attributes($attributes, &$source) { $s = null; foreach($attributes as $key) { if(isset($source[$key])) { $this->setAttribute($key, $source[$key], $s, 'PDO::__construct'); unset($source[$key]); } } } private function close() { if($this->link) { if($this->in_transaction) { $this->rollback(); } if(!$this->driver_options[PDO::ATTR_PERSISTENT]) { $this->disconnect(); } } $this->link = null; } private function check_attr_statement_class(&$data, &$func) { if( is_array($data) && isset($data[0]) && class_exists($data[0]) ) { if(isset($data[1]) && !is_array($data[1])) { $this->set_error(0, 'General error: PDO::ATTR_STATEMENT_CLASS requires format array(classname, array(ctor_args)); ctor_args must be an array', 'HY000', PDO::ERRMODE_WARNING, $func); return false; } return true; } $this->set_error(0, 'General error: PDO::ATTR_STATEMENT_CLASS requires format array(classname, array(ctor_args)); the classname must be a string specifying an existing class', 'HY000', PDO::ERRMODE_WARNING, $func); return false; } private function get_error_str($code, $message, $state, $func = '') { if($func) { if(strpos($func, '::') === false) { $class_name = 'PDO'; } else { $arr = explode('::', $func); $class_name = $arr[0]; $func = $arr[1]; } if(isset($_SERVER['GATEWAY_INTERFACE'])) { $prefix = $class_name . '::' . $func . '() [<a href=\'function.' . $class_name . '-' . $func . '\'>function.' . $class_name . '-' . $func . '</a>]: '; } else { $prefix = $class_name . '::' . $func . '(): '; } } else { $prefix = ''; } if($code) return $prefix . 'SQLSTATE['.$state.'] ['.$code.'] ' . $message; return $prefix . 'SQLSTATE['.$state.']: ' . $message; } } class dbf_base_statement_iterator implements Iterator { private $stmt; private $row; private $cnt = -1; public function __construct(PDOStatement $stmt) { $this->stmt = $stmt; } public function key() { return $this->cnt; } public function rewind() { $this->next(); } public function current() { return $this->row; } public function next() { $this->row = $this->stmt->fetch(); $this->cnt++; } public function valid() { if($this->row === false) return false; return true; } } $dbf_error_reporting = error_reporting(); if(version_compare(PHP_VERSION, '5.2.7', '<') && ($dbf_error_reporting & E_STRICT)) { error_reporting($dbf_error_reporting & ~E_STRICT); } else { $dbf_error_reporting = null; } abstract class dbf_base_statement extends PDOStatement implements IteratorAggregate { protected $_driver; protected $_link; protected $_result = null; protected $_result_name; protected $_params_info; protected $_bound_params = array(); private $driver_options = array(); private $last_error = array(''); private $prepared; private $bound_columns = array(); private $columns_meta = null; private $fetch_func = 'fetch'; private $fetch_mode = array ( PDO::FETCH_COLUMN => array(0), ); public function getIterator() { return new dbf_base_statement_iterator($this); } public function bindColumn($column, &$param, $type = 0, $maxlen = 0, $driver_options = null) { if($this->_result === null) { return false; } else if(is_numeric($column)) { if($column < 1) { $this->_set_error(0, 'Invalid parameter number: Columns/Parameters are 1-based', 'HY093', PDO::ERRMODE_WARNING, 'bindColumn'); return false; } $column -= 1; } $this->bound_columns[$column] = array(&$param, $type); return true; } public function bindParam($parameter, &$variable, $data_type = -1, $length = 0, $driver_options = null) { if($parameter[0] != ':' && !is_numeric($parameter)) { $parameter = ':' . $parameter; } if(isset($this->_params_info[$parameter])) { $this->_bound_params[$this->_params_info[$parameter]] = array(&$variable, $data_type, $length); return true; } return false; } public function bindValue($parameter, $value, $data_type = -1) { return $this->bindParam($parameter, $value, $data_type); } public function errorCode() { if(func_num_args() > 0) return false; return $this->last_error[0]; } public function errorInfo() { if(func_num_args() > 0) return false; return $this->last_error; } public function execute($input_parameters = array()) { if(!$this->prepared) { $this->_set_error(0, 'Invalid parameter number: statement not prepared', 'HY093', PDO::ERRMODE_WARNING, 'execute'); return false; } if(is_array($input_parameters)) { $status = true; foreach($input_parameters as $p => &$v) { if(is_numeric($p)) { if($p >= 0) { $status = $this->bindParam(($p + 1), $v); } } else { $status = $this->bindParam($p, $v); } if(!$status) { $this->_set_error(0, 'Invalid parameter number: number of bound variables does not match number of tokens', 'HY093', PDO::ERRMODE_WARNING, 'execute'); return false; } } } if($this->_execute()) { $this->_driver->clear_error($this->last_error); return true; } return false; } public function fetch($fetch_style = 0, $cursor_orientation = 0, $cursor_offset = 0) { if($this->_result) { $fetch_mode =& $this->fetch_mode; switch($fetch_style) { case 0: $fetch_style = $this->driver_options[PDO::ATTR_DEFAULT_FETCH_MODE]; switch($fetch_style) { case PDO::FETCH_CLASS: case PDO::FETCH_CLASS|PDO::FETCH_PROPS_LATE: if(!isset($fetch_mode[PDO::FETCH_CLASS]) || !$fetch_mode[PDO::FETCH_CLASS][0]) { $this->_set_error(0, 'General error: No fetch class specified', 'HY000', PDO::ERRMODE_SILENT, $this->fetch_func); $this->_set_error(0, 'General error', 'HY000', PDO::ERRMODE_SILENT, $this->fetch_func); return false; } break; } break; case PDO::FETCH_GROUP: $fetch_style |= $this->driver_options[PDO::ATTR_DEFAULT_FETCH_MODE]; break; } switch($fetch_style) { case PDO::FETCH_COLUMN: return $this->fetchColumn($fetch_mode[PDO::FETCH_COLUMN][0]); break; case PDO::FETCH_FUNC: $this->_set_error(0, 'General error: PDO::FETCH_FUNC is only allowed in PDOStatement::fetchAll()', 'HY000', PDO::ERRMODE_WARNING, $this->fetch_func); return false; break; } $row = $this->_fetch_row(); if(!$row) return false; $stringify = $this->driver_options[PDO::ATTR_STRINGIFY_FETCHES]; $nulls = $this->driver_options[PDO::ATTR_ORACLE_NULLS]; if($stringify || $nulls != PDO::NULL_NATURAL) { $driver = $this->_driver; $cnt = count($row); for($x = 0; $x < $cnt; $x++) { $driver->filter_result($row[$x], $stringify, $nulls); } } if($this->bound_columns && $this->fetch_func == 'fetch') { $this->bind_columns($row); } switch($fetch_style) { case PDO::FETCH_ASSOC: return $this->make_assoc($row); break; case PDO::FETCH_ASSOC|PDO::FETCH_GROUP: $row = $this->make_assoc($row); return array(array_shift($row) => $row); break; case PDO::FETCH_NAMED: return $this->make_named($row); break; case PDO::FETCH_NUM: return $row; break; case PDO::FETCH_NUM|PDO::FETCH_GROUP: return array(array_shift($row) => $row); break; case PDO::FETCH_BOTH: return $this->make_both($row); break; case PDO::FETCH_LAZY: case PDO::FETCH_OBJ: return $this->map_obj_props(new stdClass(), $row); break; case PDO::FETCH_CLASS: case PDO::FETCH_CLASS|PDO::FETCH_PROPS_LATE: if(isset($fetch_mode[PDO::FETCH_CLASS]) && $fetch_mode[PDO::FETCH_CLASS][0]) { $class_name = $fetch_mode[PDO::FETCH_CLASS][0]; } else { $class_name = 'stdClass'; } if(isset($fetch_mode[PDO::FETCH_CLASS]) && $fetch_mode[PDO::FETCH_CLASS][1]) { $class = new ReflectionClass($class_name); $obj = $class->newInstanceArgs($fetch_mode[PDO::FETCH_CLASS][1]); } else { $obj = new $class_name(); } return $this->map_obj_props($obj, $row); break; case PDO::FETCH_CLASS|PDO::FETCH_CLASSTYPE: case PDO::FETCH_CLASS|PDO::FETCH_CLASSTYPE|PDO::FETCH_SERIALIZE: $class = array_shift($row); if(!$class) { if(isset($fetch_mode[PDO::FETCH_CLASS|PDO::FETCH_CLASSTYPE]) && $fetch_mode[PDO::FETCH_CLASS|PDO::FETCH_CLASSTYPE][0]) { $class = $fetch_mode[PDO::FETCH_CLASS|PDO::FETCH_CLASSTYPE][0]; } else { $class = 'stdClass'; } } $obj = new $class(); if($fetch_style & PDO::FETCH_SERIALIZE) { if(is_callable(array($obj, 'unserialize'))) { $obj->unserialize(array_shift($row)); } else { $this->_set_error(0, 'General error: cannot unserialize class', 'HY000', PDO::ERRMODE_SILENT, $this->fetch_func); return false; } } else { $this->map_obj_props($obj, $row, 1); } return $obj; break; case PDO::FETCH_INTO: return $this->map_obj_props($fetch_mode[PDO::FETCH_INTO][0], $row); break; case PDO::FETCH_KEY_PAIR: if(count($row) != 2) { $this->_set_error(0, 'General error: PDO::FETCH_KEY_PAIR fetch mode requires the result set to contain extactly 2 columns.', 'HY000', PDO::ERRMODE_SILENT, $this->fetch_func); $this->_set_error(0, 'General error', 'HY000', PDO::ERRMODE_SILENT, $this->fetch_func); return false; } return array($row[0] => &$row[1]); break; case PDO::FETCH_BOUND: return true; break; } } return false; } public function fetchAll($fetch_style = 0, $column_index = null, $ctor_args = array()) { if(!$this->_result) return false; $result = array(); if($fetch_style) { $style = $fetch_style; } else { $style = $this->driver_options[PDO::ATTR_DEFAULT_FETCH_MODE]; } $this->fetch_func = 'fetchAll'; switch($style) { case PDO::FETCH_ASSOC: case PDO::FETCH_NAMED: case PDO::FETCH_NUM: case PDO::FETCH_BOTH: case PDO::FETCH_LAZY: case PDO::FETCH_OBJ: case PDO::FETCH_INTO: case PDO::FETCH_BOUND: case PDO::FETCH_GROUP: while($row = $this->fetch($fetch_style)) { $result[] = $row; } break; case PDO::FETCH_FUNC: case PDO::FETCH_FUNC|PDO::FETCH_GROUP: if(!$column_index && isset($this->fetch_mode[PDO::FETCH_FUNC])) { $column_index = $this->fetch_mode[PDO::FETCH_FUNC][0]; } if($column_index) { if(is_callable($column_index)) { if($style & PDO::FETCH_GROUP) { while($row = $this->fetch(PDO::FETCH_NUM)) { $key = array_shift($row); if(isset($result[$key])) { $result[$key][] = call_user_func_array($column_index, $row); } else { $result[$key] = array(call_user_func_array($column_index, $row)); } } } else { while($row = $this->fetch(PDO::FETCH_NUM)) { $result[] = call_user_func_array($column_index, $row); } } } else { $this->_set_error(0, 'General error: user-supplied function must be a valid callback', 'HY000', PDO::ERRMODE_WARNING, $this->fetch_func); } } else { $this->_set_error(0, 'General error: No fetch function specified', 'HY000', PDO::ERRMODE_WARNING, $this->fetch_func); if($style != $fetch_style) { $this->_set_error(0, 'General error', 'HY000', PDO::ERRMODE_SILENT, $this->fetch_func); } } break; case PDO::FETCH_CLASS: case PDO::FETCH_CLASS|PDO::FETCH_PROPS_LATE: if($column_index) { $this->setFetchMode(PDO::FETCH_CLASS, $column_index, $ctor_args); } while($row = $this->fetch($fetch_style)) { $result[] = $row; } break; case PDO::FETCH_CLASS|PDO::FETCH_CLASSTYPE: $this->setFetchMode(PDO::FETCH_CLASS|PDO::FETCH_CLASSTYPE, $column_index, $ctor_args); while($row = $this->fetch(PDO::FETCH_CLASS|PDO::FETCH_CLASSTYPE)) { $result[] = $row; } break; case PDO::FETCH_CLASS|PDO::FETCH_CLASSTYPE|PDO::FETCH_GROUP: $this->setFetchMode(PDO::FETCH_CLASS|PDO::FETCH_CLASSTYPE, $column_index, $ctor_args); $first_property = null; while($row = $this->fetch(PDO::FETCH_CLASS|PDO::FETCH_CLASSTYPE)) { if($first_property === null) { $first_property = key(get_object_vars($row)); } $key = $row->$first_property; unset($row->$first_property); if(isset($result[$key])) { $result[$key][] = $row; } else { $result[$key] = array($row); } } break; case PDO::FETCH_CLASS|PDO::FETCH_CLASSTYPE|PDO::FETCH_UNIQUE: $this->setFetchMode(PDO::FETCH_CLASS|PDO::FETCH_CLASSTYPE, $column_index, $ctor_args); $first_property = null; while($row = $this->fetch(PDO::FETCH_CLASS|PDO::FETCH_CLASSTYPE)) { if($first_property === null) { $first_property = key(get_object_vars($row)); } $key = $row->$first_property; unset($row->$first_property); $result[$key] = $row; } break; case PDO::FETCH_CLASS|PDO::FETCH_CLASSTYPE|PDO::FETCH_SERIALIZE: $this->setFetchMode(PDO::FETCH_CLASS|PDO::FETCH_CLASSTYPE, $column_index, $ctor_args); while($row = $this->fetch(PDO::FETCH_CLASS|PDO::FETCH_CLASSTYPE|PDO::FETCH_SERIALIZE)) { $result[] = $row; } break; case PDO::FETCH_KEY_PAIR: while($row = $this->fetch(PDO::FETCH_NUM)) { $result[$row[0]] = $row[1]; } break; case PDO::FETCH_COLUMN: if($column_index === null) $column_index = $this->fetch_mode[PDO::FETCH_COLUMN][0]; while(($row = $this->fetchColumn($column_index)) !== false) { $result[] = $row; } break; case PDO::FETCH_COLUMN|PDO::FETCH_UNIQUE: if($column_index === null) $column_index = 1; while($row = $this->fetch(PDO::FETCH_NUM)) { if(isset($result[$row[0]])) continue; $result[$row[0]] = $row[$column_index]; } break; case PDO::FETCH_COLUMN|PDO::FETCH_GROUP: if($column_index === null) $column_index = 1; while($row = $this->fetch(PDO::FETCH_NUM)) { $key = $row[0]; if(isset($result[$key])) { $result[$key][] = $row[$column_index]; } else { $result[$key] = array($row[$column_index]); } } break; case PDO::FETCH_UNIQUE|PDO::FETCH_ASSOC: case PDO::FETCH_UNIQUE|PDO::FETCH_NUM: $s = $style & ~PDO::FETCH_UNIQUE; while($row = $this->fetch($s)) { $result[array_shift($row)] = $row; } break; case PDO::FETCH_GROUP|PDO::FETCH_ASSOC: case PDO::FETCH_GROUP|PDO::FETCH_NUM: case PDO::FETCH_COLUMN|PDO::FETCH_NUM: $s = $style & ~PDO::FETCH_GROUP; if($s == PDO::FETCH_COLUMN) { if($column_index === null) $column_index = $fetch_mode[PDO::FETCH_COLUMN][0]; while($row = $this->fetch(PDO::FETCH_NUM)) { $key = array_shift($row[$column_index]); if(isset($result[$key])) { $result[$key] = array_merge($result[$key], $row); } else { $result[$key] = array($row); } } } else { while($row = $this->fetch($s)) { $key = array_shift($row); if(isset($result[$key])) { $result[$key][] = $row; } else { $result[$key] = array($row); } } } break; } $this->fetch_func = 'fetch'; return $result; } public function fetchColumn($column_number = 0) { if($this->_result) { $row = $this->_fetch_row(); if($row && array_key_exists($column_number, $row)) { $this->_driver->filter_result($row[$column_number], $this->driver_options[PDO::ATTR_STRINGIFY_FETCHES], $this->driver_options[PDO::ATTR_ORACLE_NULLS]); return $row[$column_number]; } } return false; } public function fetchObject($class_name = '', $ctor_args = array()) { if($class_name) { $this->setFetchMode(PDO::FETCH_CLASS, $class_name, $ctor_args); } return $this->fetch(PDO::FETCH_CLASS); } public function getAttribute($attribute) { if(func_num_args() != 1 || !is_int($attribute)) return false; return $this->_driver->getAttribute($attribute, $this->driver_options, 'PDOStatement::getAttribute', $this->last_error); } public function nextRowset() { return false; } public function setAttribute($attribute, $value) { if(func_num_args() != 2) return false; switch($attribute) { case PDO::ATTR_PREFETCH: $this->_set_error(0, 'Driver does not support this function: This driver doesn\'t support setting attributes', 'IM001', PDO::ERRMODE_WARNING, 'setAttribute', $this->last_error); break; default: return $this->_driver->setAttribute($attribute, $value, $this->driver_options, 'PDOStatement::setAttribute', $this->last_error); break; } return false; } public function setFetchMode($mode, $param = '', $ctorargs = array()) { switch($mode) { case PDO::FETCH_LAZY: case PDO::FETCH_ASSOC: case PDO::FETCH_NAMED: case PDO::FETCH_NUM: case PDO::FETCH_BOTH: case PDO::FETCH_OBJ: case PDO::FETCH_BOUND: case PDO::FETCH_COLUMN: case PDO::FETCH_FUNC: case PDO::FETCH_CLASS: case PDO::FETCH_INTO: case PDO::FETCH_KEY_PAIR: case PDO::FETCH_SERIALIZE: case PDO::FETCH_CLASS|PDO::FETCH_CLASSTYPE: switch($mode) { case PDO::FETCH_INTO: if(!is_object($param)) return false; break; case PDO::FETCH_CLASS: if(!class_exists($param)) return false; break; case PDO::FETCH_CLASS|PDO::FETCH_CLASSTYPE: if($param && !class_exists($param)) return false; break; case PDO::FETCH_COLUMN: if(!is_numeric($param) || $param < 0) return false; break; } $this->fetch_mode[$mode] = array(&$param, $ctorargs); $this->driver_options[PDO::ATTR_DEFAULT_FETCH_MODE] = $mode; return true; break; } return false; } public static function _new_instance(&$data, &$statement) { if(isset($data[1]) && count($data[1])) { $class = new ReflectionClass($data[0]); $obj = $class->newInstanceArgs($data[1]); } else { $obj = new $data[0]; } $obj->queryString =& $statement; return $obj; } final public function _setup($link, $driver, &$driver_options, $prepared, $params_info) { if($this->_link) return false; $this->_link = $link; $this->_driver = $driver; $this->driver_options += $driver_options; $this->prepared =& $prepared; $this->_params_info =& $params_info; } final public function _set_result($result, $result_name = '') { if($this->_result !== null) return false; $this->_result = $result; $this->_result_name = $result_name; } protected function _set_error($code, $message, $state = 'HY000', $mode = PDO::ERRMODE_SILENT, $func = '') { if($func && strpos($func, '::') === false) { $func = 'PDOStatement::' . $func; } $this->_driver->set_error($code, $message, $state, $mode, $func, $this->last_error); } abstract protected function _set_stmt_error($state = null, $mode = PDO::ERRMODE_SILENT, $func = ''); abstract protected function _execute(); abstract protected function _fetch_row(); abstract protected function _field_name($field); abstract protected function _table_name($field); protected function _build_query() { $params =& $this->_bound_params; $params_cnt = count($params); $params_info_cnt = count($this->_params_info); if($params_info_cnt && !$params_cnt) { $this->_set_error(0, 'Invalid parameter number: no parameters were bound', 'HY093', PDO::ERRMODE_WARNING, 'execute'); return false; } if($params_info_cnt != $params_cnt) { $this->_set_error(0, 'Invalid parameter number: number of bound variables does not match number of tokens', 'HY093', PDO::ERRMODE_WARNING, 'execute'); return false; } $prepared =& $this->prepared; $driver =& $this->_driver; foreach($params as $k => &$v) { $param =& $v[0]; $type = $v[1]; if($type == PDO::PARAM_LOB && is_resource($param)) { $buffer = ''; while(!feof($param)) { $buffer .= fread($param, 8192); } $prepared[$k] = $driver->quote($buffer, PDO::PARAM_STR); } else { if($type == -1) { if(is_int($param) || is_float($param)) { $type = PDO::PARAM_INT; } else if(is_bool($param)) { $type = PDO::PARAM_BOOL; } else if(is_null($param)) { $type = PDO::PARAM_NULL; } else { $type = PDO::PARAM_STR; } } $prepared[$k] = $driver->quote($param, $type); } } return implode(' ', $prepared); } protected function _fetch_lob(&$p, &$col) { $p = tmpfile(); if($p) { fwrite($p, $col); rewind($p); } } private function make_assoc(&$row) { if(!$this->columns_meta) { $this->fetch_columns_meta(); } return array_combine($this->columns_meta[1], $row); } private function make_both(&$row) { if(!$this->columns_meta) { $this->fetch_columns_meta(); } $fields =& $this->columns_meta[1]; $result = array(); foreach($row as $k => &$v) { $result[$k] = $v; $result[$fields[$k]] = $v; } return $result; } private function make_named(&$row) { if(!$this->columns_meta) { $this->fetch_columns_meta(); } $fields =& $this->columns_meta[1]; $result = array(); foreach($row as $k => &$v) { $fname =& $fields[$k]; if(!isset($result[$fname])) { $result[$fname] = &$v; } else if(!is_array($result[$fname])) { $result[$fname] = array($result[$fname], &$v); } else { $result[$fname][] = &$v; } } return $result; } private function map_obj_props($obj, &$row, $offset = 0) { if(!$this->columns_meta) { $this->fetch_columns_meta(); } $fields =& $this->columns_meta[0]; foreach($row as $k => &$v) { $obj->$fields[$k + $offset] = $v; } return $obj; } private function bind_columns(&$row) { if(!$this->columns_meta) { $this->fetch_columns_meta(); } $fields = array_flip($this->columns_meta[0]); foreach($this->bound_columns as $k => &$v) { if(isset($row[$k])) { $col =& $row[$k]; } else if(isset($fields[$k])) { $col =& $row[$fields[$k]]; } else { continue; } $p =& $v[0]; switch($v[1]) { case PDO::PARAM_LOB: $this->_fetch_lob($p, $col); break; default: $p = $col; break; } } } private function fetch_columns_meta() { $opt =& $this->driver_options; $case = $opt[PDO::ATTR_CASE]; $table_names = $opt[PDO::ATTR_FETCH_TABLE_NAMES]; $catalog_names = $opt[PDO::ATTR_FETCH_CATALOG_NAMES]; $x = 0; $count = $this->columnCount(); $result = array(array(), array()); $names =& $result[0]; $tables =& $result[1]; while($x < $count) { $name =& $names[$x]; $table =& $tables[$x]; $name = $this->_field_name($x); switch($case) { case PDO::CASE_LOWER: $name = strtolower($name); break; case PDO::CASE_UPPER: $name = strtoupper($name); break; } if($table_names && ($table_name = $this->_table_name($x))) { $table = $table_name . '.' . $name; } else { $table = $name; } $x++; } $this->columns_meta =& $result; } } if($dbf_error_reporting !== null) { error_reporting($dbf_error_reporting); } class dbf_mysql_statement extends dbf_base_statement { public function closeCursor() { if($this->_result) { mysql_free_result($this->_result); $this->_result = false; } } public function columnCount() { if($this->_result) { return mysql_num_fields($this->_result); } return 0; } public function rowCount() { return mysql_affected_rows($this->_link); } public function getColumnMeta($column) { if($column >= $this->columnCount()) return false; $info = mysql_fetch_field($this->_result, $column); $result = array(); if($info->def) { $result['mysql:def'] = $info->def; } $result['native_type'] = $info->type; $result['flags'] = explode(' ', mysql_field_flags($this->_result, $column)); $result['table'] = $info->table; $result['name'] = $info->name; $result['len'] = mysql_field_len($this->_result, $column); $result['precision'] = 0; $result['pdo_type'] = PDO::PARAM_STR; return $result; } protected function _execute() { $query = $this->_build_query(); if(!$query) return false; if($this->getAttribute(dbf_base::MYSQL_ATTR_USE_BUFFERED_QUERY)) { $this->_result = mysql_query($query, $this->_link); } else { $this->_result = mysql_unbuffered_query($query, $this->_link); } if(!$this->_result) { $this->_set_stmt_error(null, PDO::ERRMODE_SILENT, 'execute'); return false; } return true; } protected function _fetch_row() { return mysql_fetch_row($this->_result); } protected function _field_name($field) { return mysql_field_name($this->_result, $field); } protected function _table_name($field) { return mysql_field_table($this->_result, $field); } protected function _set_stmt_error($state = null, $mode = PDO::ERRMODE_SILENT, $func = '') { $errno = mysql_errno($this->_link); if($state === null) $state = $this->_driver->get_sql_state($errno); $this->_set_error($errno, mysql_error($this->_link), $state, $mode, $func); } } class dbf_mysql extends dbf_base { private $client_flags = 0; private $sql_states = array ( 1022 => '23000', 1037 => 'HY001', 1038 => 'HY001', 1040 => '08004', 1042 => '08S01', 1043 => '08S01', 1044 => '42000', 1045 => '28000', 1046 => '3D000', 1047 => '08S01', 1048 => '23000', 1049 => '42000', 1050 => '42S01', 1051 => '42S02', 1052 => '23000', 1053 => '08S01', 1054 => '42S22', 1055 => '42000', 1056 => '42000', 1057 => '42000', 1058 => '21S01', 1059 => '42000', 1060 => '42S21', 1061 => '42000', 1062 => '23000', 1063 => '42000', 1064 => '42000', 1065 => '42000', 1066 => '42000', 1067 => '42000', 1068 => '42000', 1069 => '42000', 1070 => '42000', 1071 => '42000', 1072 => '42000', 1073 => '42000', 1074 => '42000', 1075 => '42000', 1080 => '08S01', 1081 => '08S01', 1082 => '42S12', 1083 => '42000', 1084 => '42000', 1090 => '42000', 1091 => '42000', 1101 => '42000', 1102 => '42000', 1103 => '42000', 1104 => '42000', 1106 => '42000', 1107 => '42000', 1109 => '42S02', 1110 => '42000', 1112 => '42000', 1113 => '42000', 1115 => '42000', 1118 => '42000', 1120 => '42000', 1121 => '42000', 1131 => '42000', 1132 => '42000', 1133 => '42000', 1136 => '21S01', 1138 => '22004', 1139 => '42000', 1140 => '42000', 1141 => '42000', 1142 => '42000', 1143 => '42000', 1144 => '42000', 1145 => '42000', 1146 => '42S02', 1147 => '42000', 1148 => '42000', 1149 => '42000', 1152 => '08S01', 1153 => '08S01', 1154 => '08S01', 1155 => '08S01', 1156 => '08S01', 1157 => '08S01', 1158 => '08S01', 1159 => '08S01', 1160 => '08S01', 1161 => '08S01', 1162 => '42000', 1163 => '42000', 1164 => '42000', 1166 => '42000', 1167 => '42000', 1169 => '23000', 1170 => '42000', 1171 => '42000', 1172 => '42000', 1173 => '42000', 1177 => '42000', 1178 => '42000', 1179 => '25000', 1184 => '08S01', 1189 => '08S01', 1190 => '08S01', 1203 => '42000', 1207 => '25000', 1211 => '42000', 1213 => '40001', 1216 => '23000', 1217 => '23000', 1218 => '08S01', 1222 => '21000', 1226 => '42000', 1227 => '42000', 1230 => '42000', 1231 => '42000', 1232 => '42000', 1234 => '42000', 1235 => '42000', 1239 => '42000', 1241 => '21000', 1242 => '21000', 1247 => '42S22', 1248 => '42000', 1249 => '01000', 1250 => '42000', 1251 => '08004', 1252 => '42000', 1253 => '42000', 1261 => '01000', 1262 => '01000', 1263 => '22004', 1264 => '22003', 1265 => '01000', 1280 => '42000', 1281 => '42000', 1286 => '42000', 1292 => '22007', 1303 => '2F003', 1304 => '42000', 1305 => '42000', 1308 => '42000', 1309 => '42000', 1310 => '42000', 1311 => '01000', 1312 => '0A000', 1313 => '42000', 1314 => '0A000', 1315 => '42000', 1316 => '42000', 1317 => '70100', 1318 => '42000', 1319 => '42000', 1320 => '42000', 1321 => '2F005', 1322 => '42000', 1323 => '42000', 1324 => '42000', 1325 => '24000', 1326 => '24000', 1327 => '42000', 1329 => '02000', 1330 => '42000', 1331 => '42000', 1332 => '42000', 1333 => '42000', 1335 => '0A000', 1336 => '0A000', 1337 => '42000', 1338 => '42000', 1339 => '20000', 1365 => '22012', 1367 => '22007', 1370 => '42000', 1397 => 'XAE04', 1398 => 'XAE05', 1399 => 'XAE07', 1400 => 'XAE09', 1401 => 'XAE03', 1402 => 'XA100', 1403 => '42000', 1406 => '22001', 1407 => '42000', 1410 => '42000', 1413 => '42000', 1414 => '42000', 1415 => '0A000', 1416 => '22003', 1425 => '42000', 1426 => '42000', 1427 => '42000', 1437 => '42000', 1439 => '42000', 1440 => 'XAE08', 1441 => '22008', 1451 => '23000', 1452 => '23000', 1453 => '42000', 1458 => '42000', 1460 => '42000', 1461 => '42000', 1463 => '42000', ); public function __construct(&$dsn, &$username, &$password, &$driver_options) { if(!extension_loaded('mysql')) { throw new PDOException('could not find extension'); } $this->driver_options[dbf_base::MYSQL_ATTR_USE_BUFFERED_QUERY] = 1; $this->driver_options[dbf_base::MYSQL_ATTR_LOCAL_INFILE] = false; $this->driver_options[dbf_base::MYSQL_ATTR_INIT_COMMAND] = ''; $this->driver_options[dbf_base::MYSQL_ATTR_READ_DEFAULT_FILE] = false; $this->driver_options[dbf_base::MYSQL_ATTR_READ_DEFAULT_GROUP] = false; $this->driver_options[dbf_base::MYSQL_ATTR_MAX_BUFFER_SIZE] = 1048576; $this->driver_options[dbf_base::MYSQL_ATTR_DIRECT_QUERY] = 1; parent::__construct($dsn, $username, $password, $driver_options); } public function beginTransaction() { parent::beginTransaction(); if(!mysql_unbuffered_query('START TRANSACTION', $this->link)) { $this->set_driver_error(null, PDO::ERRMODE_EXCEPTION, 'beginTransaction'); } return true; } public function commit() { parent::commit(); if(!mysql_unbuffered_query('COMMIT', $this->link)) { $this->set_driver_error(null, PDO::ERRMODE_EXCEPTION, 'commit'); } $this->setAttribute(PDO::ATTR_AUTOCOMMIT, 1); return true; } public function exec(&$statement) { if($result = mysql_unbuffered_query($statement, $this->link)) { if(is_resource($result)) { mysql_free_result($result); return 0; } return mysql_affected_rows($this->link); } return false; } public function getAttribute($attribute, &$source = null, $func = 'PDO::getAttribute', &$last_error = null) { if($source == null) $source =& $this->driver_options; switch($attribute) { case PDO::ATTR_AUTOCOMMIT: $result = mysql_unbuffered_query('SELECT @@AUTOCOMMIT', $this->link); if(!$result) { $this->set_driver_error(null, PDO::ERRMODE_EXCEPTION, $func); } $row = mysql_fetch_row($result); mysql_free_result($result); return intval($row[0]); break; case PDO::ATTR_TIMEOUT: return intval(ini_get('mysql.connect_timeout')); break; case PDO::ATTR_CLIENT_VERSION: return mysql_get_client_info(); break; case PDO::ATTR_CONNECTION_STATUS: return mysql_get_host_info($this->link); break; case PDO::ATTR_SERVER_INFO: return mysql_stat($this->link); break; case PDO::ATTR_SERVER_VERSION: return mysql_get_server_info($this->link); break; default: return parent::getAttribute($attribute, $source, $func, $last_error); break; } } public function lastInsertId($name = '') { return mysql_insert_id($this->link); } public function quote(&$param, $parameter_type = -1) { switch($parameter_type) { case PDO::PARAM_BOOL: return $param ? 1 : 0; break; case PDO::PARAM_NULL: return 'NULL'; break; case PDO::PARAM_INT: return is_null($param) ? 'NULL' : (is_int($param) ? $param : (float)$param); break; default: return is_null($param) ? 'NULL' : '\'' . mysql_real_escape_string($param, $this->link) . '\''; break; } } public function rollBack() { parent::rollback(); if(!mysql_unbuffered_query('ROLLBACK', $this->link)) { $this->set_driver_error(null, PDO::ERRMODE_EXCEPTION, 'rollBack'); } $this->setAttribute(PDO::ATTR_AUTOCOMMIT, $this->driver_options[PDO::ATTR_AUTOCOMMIT]); return true; } public function setAttribute($attribute, $value, &$source = null, $func = 'PDO::setAttribute', &$last_error = null) { if($source == null) $source =& $this->driver_options; switch($attribute) { case PDO::ATTR_AUTOCOMMIT: $value = $value ? 1 : 0; if(!mysql_unbuffered_query('SET AUTOCOMMIT = ' . $value, $this->link)) { $this->set_driver_error(null, PDO::ERRMODE_EXCEPTION, $func); } return true; break; case PDO::ATTR_TIMEOUT: $value = intval($value); if($value > 1 && @ini_set('mysql.connect_timeout', $value)) { return true; } break; case dbf_base::MYSQL_ATTR_LOCAL_INFILE: $value = $value ? true : false; $source[dbf_base::MYSQL_ATTR_LOCAL_INFILE] = $value; if($value && !($this->client_flags & 128)) { $this->client_flags |= 128; } else if(!$value && ($this->client_flags & 128)) { $this->client_flags &= ~128; } return true; break; case dbf_base::MYSQL_ATTR_INIT_COMMAND: if($value) { $source[dbf_base::MYSQL_ATTR_INIT_COMMAND] = $value; return true; } break; default: return parent::setAttribute($attribute, $value, $source, $func, $last_error); break; } return false; } public function set_driver_error($state = null, $mode = PDO::ERRMODE_SILENT, $func = '') { $errno = mysql_errno($this->link); if($state === null) $state = $this->get_sql_state($errno); $this->set_error($errno, mysql_error($this->link), $state, $mode, $func); } public function get_sql_state($id) { if(isset($this->sql_states[$id])) { return $this->sql_states[$id]; } return 'HY000'; } protected function connect(&$username, &$password, &$driver_options) { $this->set_attributes(array ( PDO::ATTR_TIMEOUT, dbf_base::MYSQL_ATTR_LOCAL_INFILE, dbf_base::MYSQL_ATTR_INIT_COMMAND, ), $driver_options); $host = isset($this->dsn['host']) ? $this->dsn['host'] : 'localhost'; $dbname = isset($this->dsn['dbname']) ? $this->dsn['dbname'] : ''; $port = isset($this->dsn['port']) ? intval($this->dsn['port']) : 0; $socket = isset($this->dsn['unix_socket']) ? intval($this->dsn['unix_socket']) : ''; if($socket) { $host .= ':' . $socket; } else if($port) { $host .= ':' . $port; } if(isset($driver_options[PDO::ATTR_PERSISTENT]) && $driver_options[PDO::ATTR_PERSISTENT]) { $this->link = @mysql_pconnect($host, $username, $password, $this->client_flags); } else { $this->link = @mysql_connect($host, $username, $password, true, $this->client_flags); } if(!$this->link) { $errno = mysql_errno(); $state = $this->get_sql_state($errno); $this->set_error($errno, mysql_error(), $state, PDO::ERRMODE_EXCEPTION, '__construct'); } if($dbname) { if(!@mysql_select_db($dbname, $this->link)) { $this->set_driver_error(null, PDO::ERRMODE_EXCEPTION, '__construct'); } } if(isset($this->dsn['charset'])) { if(!mysql_set_charset($this->dsn['charset'], $this->link)) { $this->set_driver_error(null, PDO::ERRMODE_EXCEPTION, '__construct'); } } if($this->driver_options[dbf_base::MYSQL_ATTR_INIT_COMMAND]) { if(!mysql_unbuffered_query($this->driver_options[dbf_base::MYSQL_ATTR_INIT_COMMAND], $this->link)) { $this->set_driver_error(null, PDO::ERRMODE_EXCEPTION, '__construct'); } } } protected function disconnect() { mysql_close($this->link); } } class DBF_PDO extends PDO { private $path; private $driver; private $driver_name; public function __construct($dsn, $username = '', $password = '', $driver_options = array()) { if(!is_array($driver_options)) $driver_options = array(); $driver_dsn =& $this->parse_dsn($dsn); if($this->driver_name == 'uri') { $driver_dsn = $this->get_uri_dsn(key($driver_dsn)); } $this->init_driver($driver_dsn, $username, $password, $driver_options); } public function beginTransaction() { return $this->driver->beginTransaction(); } public function commit() { return $this->driver->commit(); } public function errorCode() { if(func_num_args() > 0) return false; return $this->driver->errorCode(); } public function errorInfo() { if(func_num_args() > 0) return false; return $this->driver->errorInfo(); } public function exec($statement) { if(!$statement || func_num_args() != 1) return false; $driver = $this->driver; $result = $driver->exec($statement); if($result !== false) { $driver->clear_error(); } else { $driver->set_driver_error(null, PDO::ERRMODE_SILENT, 'exec'); } return $result; } public function getAttribute($attribute) { if(func_num_args() != 1 || !is_int($attribute)) return false; return $this->driver->getAttribute($attribute); } public function lastInsertId($name = '') { if(!is_string($name) || func_num_args() > 1) return false; $result = $this->driver->lastInsertId($name); $driver = $this->driver; if($result !== false) { $driver->filter_result($result, $driver->driver_options[PDO::ATTR_STRINGIFY_FETCHES], $driver->driver_options[PDO::ATTR_ORACLE_NULLS]); } return $result; } public function prepare($statement, $driver_options = array()) { return $this->driver->prepare($statement, $driver_options); } public function query($statement, $mode = 0, $param = '', $ctorargs = array()) { $st = $this->prepare($statement); if(!$st) return false; try { if(!$st->execute()) { $this->driver->set_error_info($st->errorInfo()); return false; } } catch(PDOException $e) { $this->driver->set_error_info($st->errorInfo()); throw $e; } if(!$mode) return $st; if(!$st->setFetchMode($mode, $param, $ctorargs)) return false; return $st; } public function quote($string, $parameter_type = -1) { if(!func_num_args() || is_array($string) || is_object($string)) return false; return $this->driver->quote($string, $parameter_type); } public function rollBack() { return $this->driver->rollback(); } public function setAttribute($attribute, $value) { if(func_num_args() != 2) return false; return $this->driver->setAttribute($attribute, $value); } private function get_uri_dsn($driver_dsn) { $uri_data =& $this->parse_uri($driver_dsn); switch($uri_data[0]) { case 'file': if(false === ($dsn = file_get_contents($uri_data[1]))) { throw new PDOException('invalid data source name'); } return $this->parse_dsn($dsn); break; default: throw new PDOException('invalid data source name'); break; } } private function &parse_dsn(&$dsn) { $pos = strpos($dsn, ':'); if($pos === false) throw new PDOException('invalid data source name'); $this->driver_name = strtolower(trim(substr($dsn, 0, $pos))); if(!$this->driver_name) throw new PDOException('could not find driver'); $driver_dsn = array(); $d_dsn = trim(substr($dsn, $pos + 1)); if($d_dsn) { $arr = explode(';', $d_dsn); foreach($arr as &$pair) { $kv = explode('=', $pair); $driver_dsn[strtolower(trim($kv[0]))] = isset($kv[1]) ? trim($kv[1]) : ''; } } return $driver_dsn; } private function &parse_uri($dsn) { $pos = strpos($dsn, ':'); if($pos === false) throw new PDOException('invalid data source name'); $data = array(strtolower(trim(substr($dsn, 0, $pos)))); $data[] = trim(substr($dsn, $pos + 1)); return $data; } private function init_driver(&$dsn, &$username, &$password, &$driver_options) { if(isset($dsn['extension']) && $dsn['extension']) { $driver = strtolower($dsn['extension']); } else { if(extension_loaded('mysql')) { $driver = 'mysql'; } } $driver_options[PDO::ATTR_DRIVER_NAME] = $this->driver_name; if(!isset($driver_options[PDO::ATTR_STATEMENT_CLASS])) { $driver_options[PDO::ATTR_STATEMENT_CLASS] = array('dbf_' . $driver . '_statement'); } $class = 'dbf_' . $driver; $this->driver = new $class($dsn, $username, $password, $driver_options); } } try { if( $dbfen_key != $backup_info['dbfen_key'] ) { logger('dbfen_key not match post="'.$dbfen_key.'", but backup_info="'.$backup_info['dbfen_key'] . '"', 'DEBUG'); die('bad req.0,exit!ip:'.$dbfen_ip.'|'.json_encode($backup_info['dbfen_ip'])); } if( $app_key != $backup_info['app_key'] ) { logger('app_key not match post="'.$app_key.'", but backup_info="'.$backup_info['app_key'] . '"', 'DEBUG'); die('bad req.1,exit!ip:'.$dbfen_ip.'|'.json_encode($backup_info['dbfen_ip'])); } if( $app_secret != $backup_info['app_secret'] ) { logger('app_secret not match post="'.$app_secret.'", but backup_info="'.$backup_info['app_secret'] . '"', 'DEBUG'); die('bad req.2,exit!ip:'.$dbfen_ip.'|'.json_encode($backup_info['dbfen_ip'])); } if( !in_array( $backup_type,array(0,1,2) ) || !in_array( $action_type,array(1,2,3,4,5,6,7) ) ) { logger('action_type not match post="'.$action_type.'", but backup_info="'.$backup_info['action_type'] . '"', 'DEBUG'); die('bad req.4,exit!'.$backup_type.'|'.$action_type); } $DBFenXBackup = new DBFenXBackup($backup_info,$db_info ); $DBFenXBackup->execute_v2(); exit(); } catch( Exception $e ) { print $e->getMessage(); exit(); } function in_limit_ips ($dbfen_ip,$limit_ips) { if( !is_array($limit_ips) ) { return false; } foreach( $limit_ips as $v) { if( strstr($dbfen_ip,$v) ) return true; } return false; } function exit_handler() { global $g_tasks; global $g_current_progress_file; global $g_finished; if( $g_exec_complete === true || $g_finished === true) { return ; } if( is_array( $g_tasks ) ) { try { if( $g_tasks[$g_current_progress_file]['ze']['close'] != 1 ) { if( is_resource($g_tasks[$g_current_progress_file]['ze']['fd']) ) $g_tasks[$g_current_progress_file]['ze']['fd']->close(); } if( $g_tasks[$g_current_progress_file]['enc']['close'] != 1 ) { if( is_resource($g_tasks[$g_current_progress_file]['enc']['fd']) ) { fclose($g_tasks[$g_current_progress_file]['enc']['fd']); } } echo json_encode(array('code'=>1,'from'=>1,'info'=>array())); } catch( Exception $ex) { echo json_encode(array('code'=>2,'from'=>1,'info'=>array(),'msg'=>$ex->getMessage())); } } else { echo json_encode(array('code'=>3,'from'=>1,'info'=>array(),'msg'=>'')); } } function logger($msg, $loglevel = 'INFO') { global $debug; global $g_log_file ; if (!$debug && $loglevel != 'INFO') return; $data = debug_backtrace(); $data = array_pop($data); $msg = "{$data['function']} ${loglevel}:\t{$msg}"; $msg = date('Y-m-d H:i:s',time()) . " {$msg}\n"; try{ file_put_contents($g_log_file,$msg, FILE_APPEND); } catch( Exception $ex) { } } Class DBFenXBackup { private $db_info =array(); private $backup_info =array(); private $fs_bgf = 'dbfen_fs_btg.dat'; private $fs_bgf_d = 'dbfen_fs_btg_detail.dat'; private $db_bgf = 'dbfen_db_btg.dat'; private $db_bgf_d = 'dbfen_db_btg_detail.dat'; private $tmp_db_gzip_file = 'dbfen-db-1.sql'; private $tmp_folder_zip_file = 'dbfen-folder-1.zip'; private $db_tb_ffl = 'dbfen_db_tb_fn.dat'; private $db_egf = 'dbfen_db_egf.dat'; private $db_iv = 'dbfen_db_iv.dat'; public $log_file = 'dbfen.log'; private $fs_dirs_scl = 'dbfen_fs_dirs.dat'; private $fs_egf = 'dbfen_fs_egf.dat'; private $fs_iv = 'dbfen_fs_iv.dat'; private $db_zip_progress_file = 'dbfen_db_zip_prg.dat'; private $fs_file_list_file = 'dbfen_fs_fl.dat'; private $fs_zip_progress_file = 'dbfen_fs_zip_prg.dat'; private $fs_tmp_file_list_file = 'dbfen_fs_tmp_fl.dat'; private $exec_complete = false; private $abnormal_exit_flag_file = 'abnormal_exit_flag_file'; public $version = '2.1'; public function __construct( $backup_info = array(),$db_info = array() ) { global $g_exec_complete; $this->db_info['db_host'] = trim($db_info['db_host']); $this->db_info['db_port'] = trim($db_info['db_port']); $this->db_info['db_name'] = trim($db_info['db_name']); $this->db_info['db_user'] = trim($db_info['db_user']); $this->db_info['db_passwd'] = trim($db_info['db_passwd']); $this->backup_info['backup_type'] = $backup_info['backup_type']; $this->backup_info['encrypt_key'] = $backup_info['encrypt_key']; $this->backup_info['app_key'] = $backup_info['app_key']; $this->backup_info['app_secret'] = $backup_info['app_secret']; $this->backup_info['dbfen_key'] = $backup_info['dbfen_key']; $this->backup_info['dbfen_ip'] = $backup_info['dbfen_ip']; $this->backup_info['tmpDir'] = $backup_info['tmpDir']; $this->backup_info['user_id'] = $backup_info['user_id']; $this->backup_info['task_id'] = $backup_info['task_id']; $this->backup_info['action_type'] = $backup_info['action_type']; if ( $backup_info['folders'][0] == '/' ) { $this->backup_info['folders'] = array($_SERVER['DOCUMENT_ROOT']); } else { $this->backup_info['folders'] = $backup_info['folders']; } $g_exec_complete = false; } private function preconfig() { global $g_log_file; global $tmp_path; if ( empty($this->backup_info['tmpDir']) || $this->backup_info['tmpDir'] == '' || !file_exists( $this->backup_info['tmpDir'] ) ) { $ret = true; if ( !is_dir( $tmp_path ) ) { $ret = @mkdir($tmp_path, 0700); if( $ret ) { $ret_1 = @mkdir($tmp_path."/dbfendb", 0700); $ret_2 = @mkdir($tmp_path."/dbfenfile", 0700); } } else { $ret_1 = @mkdir($tmp_path."/dbfendb", 0700); $ret_2 = @mkdir($tmp_path."/dbfenfile", 0700); } if ( $ret == false ) { @mkdir('/tmp/dbfendb', 0700); @mkdir('/tmp/dbfenfile', 0700); $this->backup_info['tmpDir'] = '/tmp/'; } else { $this->backup_info['tmpDir'] = $tmp_path.'/'; } } else { $this->backup_info['tmpDir'] .= end(str_split($this->backup_info['tmpDir'])) == "/" ? "" : "/"; @mkdir($this->backup_info['tmpDir'].'dbfendb', 0700); @mkdir($this->backup_info['tmpDir'].'dbfenfile', 0700); } if ($this->backup_info['backup_type'] == 1) { $this->log_file = $this->backup_info['tmpDir'].'db-'.$this->log_file; $this->backup_info['tmpDir'] = $this->backup_info['tmpDir']."dbfendb/"; } else if ( $this->backup_info['backup_type'] == 2 ) { $this->log_file = $this->backup_info['tmpDir'].'file-'.$this->log_file; $this->backup_info['tmpDir'] = $this->backup_info['tmpDir']."dbfenfile/"; } $g_log_file = $this->log_file; $this->abnormal_exit_flag_file = $this->backup_info['tmpDir'].$this->abnormal_exit_flag_file; } public function handle_shutdown_event() { global $g_tasks; global $g_current_progress_file; global $g_finished; if( $this->exec_complete === true || $g_finished === true ) { return ; } if( is_array( $g_tasks ) ) { try { if( $g_tasks[$g_current_progress_file]['ze']['close'] != 1 ) { if( is_resource($g_tasks[$g_current_progress_file]['ze']['fd']) ) { $g_tasks[$g_current_progress_file]['ze']['fd']->close(); } } if( $g_tasks[$g_current_progress_file]['enc']['close'] != 1 ) { if( is_resource( $g_tasks[$g_current_progress_file]['enc']['fd']) ) fclose($g_tasks[$g_current_progress_file]['enc']['fd']); } echo json_encode(array('code'=>1,'from'=>2,'info'=>array())); } catch( Exception $ex) { echo json_encode(array('code'=>2,'from'=>2,'info'=>array(),'msg'=>$ex->getMessage())); } } else { echo json_encode(array('code'=>3,'from'=>2,'info'=>array(),'msg'=>'')); } } public function register_shutdown_event() { try { if( function_exists('register_shutdown_function') ) { register_shutdown_function( array($this, 'handle_shutdown_event') ); } } catch( Exception $e) { return 1; } return 0; } public function execute() { if( $this->backup_info['action_type'] == 1 ) { echo json_encode(array('code'=>0)); ob_flush(); flush(); $this->preconfig(); $this->xbackup(); } else if( $this->backup_info['action_type'] == 2 ) { $this->preconfig(); $this->download(); } else if( $this->backup_info['action_type'] == 3 ) { $this->preconfig(); $this->xverify(); } else if( $this->backup_info['action_type'] == 4 ) { $this->replyping(); } } public function execute_v2() { global $g_timeout_seconds ; if (function_exists('ignore_user_abort')) { ignore_user_abort(true); } if (function_exists('set_time_limit')) { set_time_limit(0); $g_timeout_seconds = 5+time(); } if( function_exists('pcntl_signal') ) { pcntl_signal(SIGTERM, 'exit_handler'); } if( $this->backup_info['action_type'] == 1 ) { logger('backup action_type=1(backup)', 'DEBUG'); $this->register_shutdown_event(); $this->preconfig(); $ret = $this->abnormal_exit_check(); if ( $ret == 0 ) { $this->xbackup_v2(); } $this->finish(); } else if( $this->backup_info['action_type'] == 2 ) { logger('backup action_type=2(download)', 'DEBUG'); $this->preconfig(); $this->download(); } else if( $this->backup_info['action_type'] == 3 ) { logger('backup action_type=3(xverify)', 'DEBUG'); $this->preconfig(); $this->xverify(); } else if( $this->backup_info['action_type'] == 4 ) { logger('backup action_type=4(replyping)', 'DEBUG'); $this->replyping(); } else if( $this->backup_info['action_type'] == 5 ) { logger('backup action_type=5(getprogress)', 'DEBUG'); $this->preconfig(); $this->getprogress(); } else if( $this->backup_info['action_type'] == 6 ) { logger('backup action_type=6(reset_env)', 'DEBUG'); $this->preconfig(); $this->reset_env( true ); } else if( $this->backup_info['action_type'] == 7 ) { logger('backup action_type=7(is_executing)', 'DEBUG'); $this->preconfig(); $this->is_executing( ); } ob_flush(); flush(); } private function replyping() { $ret = array('code'=>0); echo json_encode($ret); } private function xverify() { $result = array(); $result['stl'] = 0; try{ $z = new ZipArchive(); $result['zia'] = 0; unset($z); } catch ( Exception $e ) { $result['zia'] = 1; } if ( !@extension_loaded('mcrypt') ) { $result['enc'] = 1; } else { $result['enc'] = 0; } if( !function_exists("gzopen") ) { $result['gz'] = 1; } else { $result['gz'] = 0; } if( class_exists('CompressManagerFactory') ) { try{ $cc = CompressManagerFactory::create( CompressMethod::GZIP ); $result['cmf'] = 0; unset($cc); } catch ( Exception $e ) { $result['cmf'] = 1; } } else { $result['cmf'] = 1; } if( !function_exists('opendir') || !function_exists('readdir') ) { $result['dop'] = 1; } else { $result['dop'] = 0; } $result['rsf'] = 0; $test_file = $this->backup_info['tmpDir'].'/dbfen_preconfig_test_2013.txt'; $fp = @fopen($test_file,'wb'); if( $fp ) { $result['tmpdir'] = 0; @fclose($fp); @unlink($test_file); } else { $result['tmpdir'] = 1; } if ( class_exists('pdo') ) { if( function_exists('mysql_connect' ) ) { if( function_exists('ini_set') ) { ini_set('mysql.connect_timeout',10); } $conn = mysql_connect( $this->db_info['db_host'].":".$this->db_info['db_port'],$this->db_info['db_user'],$this->db_info['db_passwd']) ; if( $conn == false ) { $this->db_info['db_host'] = 'localhost'; $conn = @mysql_connect( $this->db_info['db_host'].":".$this->db_info['db_port'],$this->db_info['db_user'],$this->db_info['db_passwd']) ; } if( $conn == false ) { $result['db'] = 1; } else { $tables_res = @mysql_list_tables($this->db_info['db_name'],$conn); @mysql_close($conn); if($tables_res ) { try { $pdo_con[PDO::ATTR_TIMEOUT]=10; $conn = new DBF_PDO("mysql:host={$this->db_info['db_host']}".";dbname={$this->db_info['db_name']};" . "port={$this->db_info['db_port']}",$this->db_info['db_user'], $this->db_info['db_passwd'],$pdo_con); if( $conn ) { $result['db'] = 0; unset($conn); } else { $result['db'] = 1; } } catch (PDOException $e) { $ex_str = $e->getMessage(); if( strstr($ex_str,'driver' ) ) { $result['db'] = 3; } else { $result['db'] = 4; } } } else { $result['db'] = 2; } } } else { try { $pdo_con[PDO::ATTR_TIMEOUT]=10; $conn = new DBF_PDO("mysql:host={$this->db_info['db_host']}".";dbname={$this->db_info['db_name']};" . "port={$this->db_info['db_port']}",$this->db_info['db_user'], $this->db_info['db_passwd'],$pdo_con); if( $conn == false ) { $this->db_info['db_host'] = 'localhost'; $conn = new DBF_PDO("mysql:host={$this->db_info['db_host']}".";dbname={$this->db_info['db_name']};" . "port={$this->db_info['db_port']}",$this->db_info['db_user'], $this->db_info['db_passwd'],$pdo_con); } if( $conn ) { $result['db'] = 0; unset($conn); } else { $result['db'] = 1; } } catch (PDOException $e) { $ex_str = $e->getMessage(); if( strstr($ex_str,'driver' ) ) { $result['db'] = 3; } else { $result['db'] = 4; } } } } else { $result['db'] = 3; } $result['folder'] = 0; $key =$this->backup_info['encrypt_key']; $result['ekey'] = 0; echo json_encode($result); } private function getprogress() { $pg_info = $this->getprogress_info(); echo json_encode($pg_info); } private function getprogress_info() { $progess_json_arr = array('init'=>0) ; $prg_file = ''; $prg_d_file = ''; if ($this->backup_info['backup_type'] == 1) { $prg_file = $this->backup_info['tmpDir'].$this->db_bgf; $prg_d_file = $this->backup_info['tmpDir'].$this->db_bgf_d; } else if ( $this->backup_info['backup_type'] == 2 ) { $prg_file = $this->backup_info['tmpDir'].$this->fs_bgf; $prg_d_file = $this->backup_info['tmpDir'].$this->fs_bgf_d; } if( @file_exists( $prg_file ) ) { $progess_json_str = file_get_contents( $prg_file ); logger('backup progress: ' . $progess_json_str, 'DEBUG'); if( @file_exists( $prg_d_file ) ) { $progess_json_arr = json_decode($progess_json_str,true); $progess_json_arr['extinfo'] = json_decode(file_get_contents( $prg_d_file ),true); } } return $progess_json_arr; } private function is_executing() { if( @file_exists( $this->abnormal_exit_flag_file ) ) { echo json_encode(array('doing'=>1)); } else { echo json_encode(array('doing'=>0)); } } private function abnormal_exit_check() { if( @file_exists( $this->abnormal_exit_flag_file ) ) { $this->reset_env(); } else { logger('---------reset_env at: '.date('Y-m-d h:i:s').'---------'); $x_fp = fopen($this->abnormal_exit_flag_file,'w'); if( $x_fp ) { $buf = '####################################################################################################'; $buf = $buf.$buf; stream_set_write_buffer($x_fp,0); fwrite($x_fp,$buf,strlen($buf) ); fflush($x_fp); fclose($x_fp); } else { return 1; } } return 0; } private function reset_env( $need_print = false ) { $folder = $this->backup_info['tmpDir']; try { $handle = @opendir( $folder ); if( !$handle ) { logger('failed open dir('.$folder.'),maybe no permission' ); if( $need_print ){ echo json_encode(array('code'=>1,'info'=>'failed to open dir:'.$folder )); } return ; } while ($f = @readdir($handle)) { if ($f != "." && $f != "..") { if (@is_file($folder . $f)) { @unlink( $folder . $f ); } } } logger( 'to reset env, succ.'); if( $need_print ){ echo json_encode(array('code'=>0,'info'=>'')); } } catch ( Exception $ex) { logger( 'to reset env,failed: '.$ex->getMessage() ); if( $need_print ){ echo json_encode(array('code'=>1,'info'=>$ex->getMessage())); } } } private function xbackup_v2() { global $g_current_progress_file; global $g_exec_complete; $tmpFolder = $this->backup_info['tmpDir']; if ($this->backup_info['backup_type'] == 1) { $g_current_progress_file = $tmpFolder.$this->db_bgf; logger('backup_type=1(db)', 'DEBUG'); $res['st'] = time(); $res['ret'] = $this->backup_db_v2(); logger('backup_db_v2 ret=' . $res['ret'], 'DEBUG'); if( $res['ret'] == 0 ) { $ret_zip = ZipOneDir::zipFiles( $tmpFolder.$this->tmp_db_gzip_file.'.zip', $tmpFolder.$this->db_bgf,$tmpFolder.$this->db_tb_ffl,$tmpFolder.$this->db_zip_progress_file,false,false,$tmpFolder.$this->db_bgf_d ); $res['ret'] = $ret_zip; logger('zip files res:'.$ret_zip); if( $ret_zip == 0 ) { logger('package files success.', 'DEBUG'); $ret_enc = $this->ssl_encrypt_v2($this->backup_info['encrypt_key'], $tmpFolder.$this->tmp_db_gzip_file.'.zip', $tmpFolder.$this->tmp_db_gzip_file.'.zip.aes', $tmpFolder.$this->db_egf, $tmpFolder.$this->db_bgf, $tmpFolder.$this->db_iv, $tmpFolder.$this->db_bgf_d ); logger('enc files res:'.$ret_enc); $res['ret'] = $ret_enc; if( $res['ret'] == 0 ) { logger('encrypt zip success, remove orginal zip file.', 'DEBUG'); if ( file_exists( $tmpFolder.$this->tmp_db_gzip_file.'.zip' ) && @unlink( $tmpFolder.$this->tmp_db_gzip_file.'.zip') ) { logger('zip file removed.', 'DEBUG'); } } } } $res['ct'] = time(); } else if ( $this->backup_info['backup_type'] == 2 ) { $g_current_progress_file = $tmpFolder.$this->fs_bgf; logger('backup_type=2(flolder)', 'DEBUG'); $res['st'] = time(); $res['ret'] = $this->backup_folders_v2(); if( $res['ret'] == 0 ) { $ret_enc = $this->ssl_encrypt_v2($this->backup_info['encrypt_key'], $tmpFolder.$this->tmp_folder_zip_file, $tmpFolder.$this->tmp_folder_zip_file.'.aes', $tmpFolder.$this->fs_egf, $tmpFolder.$this->fs_bgf, $tmpFolder.$this->fs_iv, $tmpFolder.$this->fs_bgf_d ); logger('enc files res:'.$ret_enc); $res['ret'] = $ret_enc; if( $ret_enc == 0 ) { if ( file_exists( $tmpFolder.$this->tmp_folder_zip_file ) ) { @unlink( $tmpFolder.$this->tmp_folder_zip_file ); } } } $res['ct'] = time(); } else { logger('backup_type "' . $backup_info["backup_type"] . '" incorrect.'); return FALSE; } if( $res['ret'] == 0 ) { logger('exec_complete is marked as completed.', 'DEBUG'); $g_exec_complete = true; $this->exec_complete = true; } return TRUE; } private function finish() { global $g_finished ; if( $this->exec_complete === true ) { echo json_encode(array('code'=>0,'from'=>0,'info'=>array('final'=>1),'v'=>$this->version)); } else { $pg_info = $this->getprogress_info(); echo json_encode(array('code'=>1,'from'=>0,'info'=>array('final'=>0),'v'=>$this->version,'pg'=>$pg_info)); } if (file_exists( $this->abnormal_exit_flag_file ) ) { @unlink( $this->abnormal_exit_flag_file ); } $g_finished = true; } private function xbackup() { if ($this->backup_info['backup_type'] == 1) { $res['st'] = time(); $res['ret'] = $this->backup_db(); if( $res['ret'] == true ) { $ret_enc = $this->ssl_encrypt($this->backup_info['encrypt_key'], $this->backup_info['tmpDir'].$this->tmp_db_gzip_file.'.gz', $this->backup_info['tmpDir'].$this->tmp_db_gzip_file.'.gz.aes'); $res['ret'] = $ret_enc; if ( file_exists( $this->backup_info['tmpDir'].$this->tmp_db_gzip_file.'.gz' ) ) unlink( $this->backup_info['tmpDir'].$this->tmp_db_gzip_file.'.gz' ); } $res['ct'] = time(); $ret = $this->send_db_backup_event( $res ); }else if ( $this->backup_info['backup_type'] == 2 ) { $res['st'] = time(); $res['ret'] = $this->backup_folders(); if( $res['ret'] == true ) { $ret_enc = $this->ssl_encrypt($this->backup_info['encrypt_key'], $this->backup_info['tmpDir'].$this->tmp_folder_zip_file, $this->backup_info['tmpDir'].$this->tmp_folder_zip_file.'.aes'); $res['ret'] = $ret_enc; if ( file_exists( $this->backup_info['tmpDir'].$this->tmp_folder_zip_file ) ) unlink( $this->backup_info['tmpDir'].$this->tmp_folder_zip_file ); } $res['ct'] = time(); $ret = $this->send_file_backup_event( $res ); }else { return FALSE; } return TRUE; } private function download( ) { $file_name = ''; $progress_file = ''; $progress_detail_file = ''; $new_file_name = ''; if( $this->backup_info['backup_type'] == 1 ) { $file_name = $this->backup_info['tmpDir'].$this->tmp_db_gzip_file.'.zip.aes' ; $progress_file = $this->backup_info['tmpDir'].$this->db_bgf; $progress_detail_file = $this->backup_info['tmpDir'].$this->db_bgf_d; } else { $file_name = $this->backup_info['tmpDir'].$this->tmp_folder_zip_file.'.aes'; $progress_file = $this->backup_info['tmpDir'].$this->fs_bgf; $progress_detail_file = $this->backup_info['tmpDir'].$this->fs_bgf_d; } $progress = file_get_contents( $progress_file ); $progress_arr = json_decode($progress,true); if( !is_array($progress_arr)) { header ("HTTP/1.0 505 Internal server error"); logger('invalid backup progress file:'.$progress_file); logger('progress file contents:' . $progress, 'DEBUG'); exit; } if (intval($progress_arr['addzip']) != 1) { header ("HTTP/1.0 505 Internal server error"); logger('zip file not ready for download.' . $progress); exit; } if (intval($progress_arr['enc']) != 1) { header ("HTTP/1.0 505 Internal server error"); logger('encrypt zip file failed.' . $progress); exit; } $progress_detail_str = file_get_contents( $progress_detail_file ); $progress_detail_arr = json_decode($progress_detail_str,true); $fsize = @filesize($file_name); $last_modified_time = date('r',@filemtime($file_name)); $begin=0; $end = $fsize; $fm=@fopen($file_name,'rb'); if( !$fm ) { logger('can not open backup res file:'.$file_name); header ("HTTP/1.0 505 Internal server error"); exit; } if(isset($_SERVER['HTTP_RANGE'])) { $range_str = $_SERVER['HTTP_RANGE']; if(strstr($range_str ,'bytes')) { try { $tmp_arr = explode("-",$range_str); $range_arr= explode('=',$tmp_arr[0]); $begin=intval($range_arr[1]); $end=intval($tmp_arr[1]); if($end < $begin) { $end = $fsize; } } catch ( Exception $ex) { logger('invalid http range header :'.$range_str); header ("HTTP/1.0 505 Internal server error"); exit; } } } if($begin > 0 || $end < $fsize) { header('HTTP/1.0 206 Partial Content'); } else { header('HTTP/1.0 200 OK'); } header("Content-type: application/octet-stream"); header("Accept-Ranges: bytes"); header('Content-Length:'.($end-$begin)); header("Content-Range: bytes $begin-".($end-1)."/$fsize"); header("Content-Type: application/force-download"); header("Content-Disposition: attachment; filename=" . $new_file_name); header("Content-Transfer-Encoding: binary"); header("Last-Modified: $last_modified_time"); header('Connection: close'); $cur=$begin; $chunksize = 1 * (1024 * 256); if( $fm ) { @fseek($fm,$begin,0); while(!@feof($fm)&&$cur<$end&&(connection_status()==0)) { print @fread($fm,min($chunksize,$end-$cur)); $download_size = min($chunksize,$end-$cur); $cur+=$chunksize; ob_flush(); flush(); $progress_detail_arr['download']['size'] = intval($progress_detail_arr['download']['size'])+$download_size; @file_put_contents($progress_detail_file,json_encode($progress_detail_arr)); } @fclose($fm); } if( $end == $fsize ) { $progress_arr['download'] = 1; file_put_contents($progress_file,json_encode($progress_arr)); } } private function send_db_backup_event( $ret ) { $url = 'http://'.$this->backup_info['dbfen_ip']['db'].'/index.php/pg/dbd/v1'; $posts = array( 'ak' => $this->backup_info['app_key'], 'as' => $this->backup_info['app_secret'], 'uid' => $this->backup_info['user_id'], 'tid' => $this->backup_info['task_id'], 'succ' => $ret['ret']?1:0, 'st' => $ret['st'], 'ct' => $ret['ct'], ); $info = $this->fetch_info_from_server( $url,$posts ); if( is_array($info) && $info['code'] == 0 ) { return TRUE; } return FALSE; } private function send_file_backup_event( $ret ) { $url = 'http://'.$this->backup_info['dbfen_ip']['fs'].'/index.php/pg/fld/v1'; $posts = array( 'ak' => $this->backup_info['app_key'], 'as' => $this->backup_info['app_secret'], 'uid' => $this->backup_info['user_id'], 'tid' => $this->backup_info['task_id'], 'succ' => $ret['ret']?1:0, 'st' => $ret['st'], 'ct' => $ret['ct'], ); $info = $this->fetch_info_from_server( $url,$posts ); if( is_array($info) && $info['code'] == 0 ) { return TRUE; } return FALSE; } private function fetch_info_from_server ( $url,$posts ) { $output = array(); $posts_str = ''; foreach( $posts as $key=>$val ) { $posts_str.=$key.'='.$val.'&'; } $posts_str .= 'v=x'; $retry_times = 0; while( $retry_times++ <5 ) { if ( function_exists('curl_init') === true ) { $ch = curl_init(); curl_setopt($ch, CURLOPT_URL, $url ); curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1); curl_setopt($ch, CURLOPT_HEADER, 0); curl_setopt($ch, CURLOPT_POST, 1); curl_setopt($ch, CURLOPT_POSTFIELDS, $posts_str ); $output = curl_exec($ch); curl_close($ch); } else { $opts = array('http' => array( 'method' => 'POST', 'content' => $posts_str ) ); $context = stream_context_create($opts); $output = file_get_contents($url,false,$context); } $output = json_decode($output,TRUE); if( !is_array( $output ) ) { @sleep(2*$retry_times); } else { break; } } return $output; } private function get_backup_folders() { $url = 'http://'.$this->backup_info['dbfen_ip']['fs'].'/index.php/pg/gf/v1'; $posts = array( 'ak'=>$this->backup_info['app_key'], 'as'=>$this->backup_info['app_secret'], 'uid'=>$this->backup_info['user_id'], 'tid'=>$this->backup_info['task_id'] ); $info = $this->fetch_info_from_server( $url ,$posts ); if( is_array($info) && is_array($info['folders'])) { $this->backup_info['folders'] = $info['folders']; return TRUE; } return FALSE; } private function backup_folders_v2() { $ret = 1; $tmpFolder = $this->backup_info['tmpDir']; $ret = ZipOneDir::scanDirs( $tmpFolder.$this->fs_bgf,$tmpFolder.$this->fs_dirs_scl,$this->backup_info['folders'],$tmpFolder.$this->fs_bgf_d); logger('scandir res:'.$ret); if( $ret == 0) { $ret = ZipOneDir::scanWholeSiteFile( $tmpFolder.$this->fs_bgf,$tmpFolder.$this->fs_dirs_scl, $tmpFolder.$this->fs_file_list_file ,$tmpFolder.$this->fs_tmp_file_list_file,$tmpFolder.$this->fs_bgf_d ); logger('scan files res:'.$ret); if( $ret == 0) { $ret = ZipOneDir::zipFiles( $tmpFolder.$this->tmp_folder_zip_file,$tmpFolder.$this->fs_bgf,$tmpFolder.$this->fs_file_list_file,$tmpFolder.$this->fs_zip_progress_file,false,true,$tmpFolder.$this->fs_bgf_d ); logger('zip files res:'.$ret); } } return $ret; } private function backup_folders() { $z = new ZipArchive(); $z->open( $this->backup_info['tmpDir'].$this->tmp_folder_zip_file, ZIPARCHIVE::CREATE); foreach( $this->backup_info['folders'] as $folder ) { ZipOneDir::folderToZip($folder, $z); } $z->close(); if( !@file_exists( $this->backup_info['tmpDir'].$this->tmp_folder_zip_file ) || @filesize( $this->backup_info['tmpDir'].$this->tmp_folder_zip_file )<=0 ) { return FALSE; } return TRUE; } private function ssl_encrypt_v2($pass, $source_file ,$dst_file,$enc_progress_file,$progress_file,$iv_file,$progress_detail_file ) { global $g_tasks; global $g_timeout_seconds; if( !@file_exists( $progress_file ) || !@file_exists( $progress_detail_file ) ) { return 7; } $progress = file_get_contents( $progress_file ); $progress_arr = json_decode($progress,true); if( is_array($progress_arr) && intval($progress_arr['enc']) == 1 ) { return 0; } $progress_detail_str = file_get_contents( $progress_detail_file ); $progress_detail_arr = json_decode($progress_detail_str,true); if( !@file_exists( $source_file ) ) { return 1; } if ( !@extension_loaded('mcrypt') ) { logger('mcrypt not exists. encryption file failed.', 'DEBUG'); return 2; } $salt = ''; $key = ''; $block = mcrypt_get_block_size(MCRYPT_RIJNDAEL_128, MCRYPT_MODE_CBC); $td = mcrypt_module_open(MCRYPT_RIJNDAEL_128, "", MCRYPT_MODE_CBC, ""); $key_len = mcrypt_enc_get_key_size($td); $iv_len = mcrypt_enc_get_iv_size($td); if( !file_exists( $iv_file ) ) { $salt = substr(md5(mt_rand(), true), 8); $total_len = $key_len + $iv_len; $salted = ''; $dx = ''; while (strlen($salted) < $total_len) { $dx = md5($dx.$pass.$salt, true); $salted .= $dx; } $key = substr($salted,0,$key_len); $iv = substr($salted,$key_len,$iv_len); $enc_ctx = "<?php\n"."\$m='".base64_encode($key)."';\n"."\$n='".base64_encode($iv)."';\n"; file_put_contents($iv_file,$enc_ctx,FILE_APPEND); } else { $tmp_fd = fopen($iv_file,"r+"); if( $tmp_fd ) { $nothing = fgets($tmp_fd); $key = fgets($tmp_fd); $key = substr($key,4,strlen($key)-6); $key = base64_decode($key); $iv = fgets($tmp_fd); $iv = substr($iv,4,strlen($iv)-6); $iv = base64_decode($iv); } else { return 5; } } mcrypt_generic_init($td, $key, $iv); $fp = @fopen($source_file,'rb'); if( !$fp ) { return 3; } $fpe = ''; if( !file_exists( $dst_file ) ) { $fpe = @fopen($dst_file,'wb'); if( !$fpe ) { @fclose( $fp ); return 4; } @fwrite($fpe, "Salted__"); @fwrite($fpe, $salt, strlen($salt)); } else { $fpe = @fopen($dst_file,'ab+'); if( !$fpe ) { @fclose( $fp ); return 6; } } $g_tasks[ $progress_file ]['enc']['fd'] = $fpe; $g_tasks[ $progress_file ]['enc']['close'] = 0; $enc_pos = 0; if( file_exists( $enc_progress_file ) ) { $enc_pos = file_get_contents($enc_progress_file); $enc_pos = intval($enc_pos); } fseek($fp,$enc_pos); fseek($fpe,$enc_pos+8+8); $one_cycle_size_enced = 0; while ( !@feof($fp) ) { $one_cycle_size_enced = 0; $cur_time = time(); if( $g_timeout_seconds <= $cur_time ) { fclose($fp); fclose($fpe); mcrypt_generic_deinit($td); mcrypt_module_close($td); return 99; } $data = @fread($fp,$block*256); $org_len = strlen($data); if( ( $org_len % $block) != 0 ) { $pad = $block - ( $org_len % $block); $data = $data . str_repeat(chr($pad), $pad); $enc_pos += $org_len; $one_cycle_size_enced = $org_len; } else { $enc_pos += 256*$block; $one_cycle_size_enced = 256*$block; } $encrypted_data = mcrypt_generic($td, $data); @fwrite($fpe,$encrypted_data,strlen($encrypted_data)); @fflush($fpe); $enc_pos_str = ''.$enc_pos ; $tmp_fd = fopen($enc_progress_file,"wb"); @fwrite($tmp_fd,$enc_pos_str,strlen($enc_pos_str)); @fflush($tmp_fd); @fclose($tmp_fd); $progress_detail_arr['enc']['size'] = intval( $progress_detail_arr['enc']['size'] )+ $one_cycle_size_enced; $progress_detail_str = json_encode($progress_detail_arr); file_put_contents( $progress_detail_file,$progress_detail_str ); } mcrypt_generic_deinit($td); mcrypt_module_close($td); @fclose($fp); @fclose($fpe); $g_tasks[ $progress_file ]['enc']['close'] = 1; $progress_arr['enc'] = 1; $progress_str = json_encode($progress_arr); file_put_contents( $progress_file,$progress_str ); return 0; } private function ssl_encrypt($pass, $source_file ,$dst_file) { if( !@file_exists( $source_file ) ) { return FALSE; } if ( !@extension_loaded('mcrypt') ) { return FALSE; } $salt = substr(md5(mt_rand(), true), 8); $block = mcrypt_get_block_size(MCRYPT_RIJNDAEL_128, MCRYPT_MODE_CBC); $td = mcrypt_module_open(MCRYPT_RIJNDAEL_128, "", MCRYPT_MODE_CBC, ""); $key_len = mcrypt_enc_get_key_size($td); $iv_len = mcrypt_enc_get_iv_size($td); $total_len = $key_len + $iv_len; $salted = ''; $dx = ''; while (strlen($salted) < $total_len) { $dx = md5($dx.$pass.$salt, true); $salted .= $dx; } $key = substr($salted,0,$key_len); $iv = substr($salted,$key_len,$iv_len); mcrypt_generic_init($td, $key, $iv); $fp = @fopen($source_file,'rb'); if( !$fp ) { return FALSE; } $fpe = @fopen($dst_file,'wb'); if( !$fpe ) { @fclose( $fp ); return FALSE; } @fwrite($fpe, "Salted__"); @fwrite($fpe, $salt, strlen($salt)); while ( !@feof($fp) ) { $data = @fread($fp,$block*256); if( (strlen($data) % $block) != 0 ) { $pad = $block - (strlen($data) % $block); $data = $data . str_repeat(chr($pad), $pad); } $encrypted_data = mcrypt_generic($td, $data); @fwrite($fpe,$encrypted_data,strlen($encrypted_data)); } mcrypt_generic_deinit($td); mcrypt_module_close($td); @fclose($fp); @fclose($fpe); return TRUE; } private function backup_db_v2() { $dumpSettings = array( 'include-tables' => array(), 'exclude-tables' => array(), 'compress' => CompressMethod::GZIP, 'no-data' => false, 'add-drop-table' => false, 'single-transaction' => true, 'lock-tables' => false, 'add-locks' => true, 'extended-insert' => true ); $ret = 0; try { $tmp_folder = $this->backup_info['tmpDir']; $dump = new MySQLDump($this->db_info['db_name'], $this->db_info['db_user'], $this->db_info['db_passwd'], $this->db_info['db_host'], $this->db_info['db_port'], $dumpSettings); $ret = $dump->start_v2($tmp_folder ,$tmp_folder.$this->db_tb_ffl, $tmp_folder.$this->db_bgf, $tmp_folder.$this->db_bgf_d); logger('start_v2 ret='.$ret.''); unset( $dump ); } catch( Exception $e ) { $ret = 1; logger('db dump err msg:'.$e->getMessage()); } logger('db dump res:'.$ret); return $ret ; } private function backup_db() { $dumpSettings = array( 'include-tables' => array(), 'exclude-tables' => array(), 'compress' => CompressMethod::GZIP, 'no-data' => false, 'add-drop-table' => false, 'single-transaction' => true, 'lock-tables' => false, 'add-locks' => true, 'extended-insert' => true ); $dump = new MySQLDump($this->db_info['db_name'],$this->db_info['db_user'],$this->db_info['db_passwd'],$this->db_info['db_host'],$this->db_info['db_port'], $dumpSettings); $dump->start( $this->backup_info['tmpDir'].$this->tmp_db_gzip_file ); if( !@file_exists( $this->backup_info['tmpDir'].$this->tmp_db_gzip_file.'.gz' ) || @filesize( $this->backup_info['tmpDir'].$this->tmp_db_gzip_file.'.gz' )<=0 ) { return FALSE; } return TRUE; } private function push_backup() { } public function __destruct() { unset($db_info); unset($folders); } } Class ZipOneDir { private static function scanOneDir( $folder ) { $dirs_arr = array(); try{ $handle = @opendir($folder); if( !$handle ) { logger('failed open dir('.$folder.'),maybe no permission' ); return $dirs_arr; } while ($f = @readdir($handle)) { if ($f != "." && $f != "..") { if (@is_file($folder ."/". $f)) { ; } elseif (is_dir($folder."/" . $f)) { $dirs_arr[$folder ."/". $f] = array(); } } } @closedir($handle); } catch( Exception $ex) { logger('failed to scan dir('.$folder.'):'.$ex->getMessage() ); } return $dirs_arr; } public static function scanDirs( $progress_file,$dir_arr_file,$folders, $progress_detail_file ) { $dirs_count = 0; if( file_exists( $progress_file ) && file_exists( $dir_arr_file ) ) { $progress = file_get_contents( $progress_file ); $progress_arr = json_decode($progress,true); if( is_array($progress_arr) && intval($progress_arr['scandir']) == 1 ) { return 0; } } $dirs_arr = array(); $notdg_dirs_arr = array(); foreach( $folders as $folder ) { $tmp_dirs_arr = ZipOneDir::scanOneDir( $folder ); $dirs_count += count($tmp_dirs_arr); $dirs_arr = array_merge($dirs_arr,$tmp_dirs_arr); $notdg_dirs_arr[]=$folder; $key_arr = array_keys($tmp_dirs_arr); $notdg_dirs_arr = array_merge($notdg_dirs_arr,$key_arr); unset($key_arr); } foreach( $dirs_arr as $key => &$subdir_arr ) { $subdir_arr = ZipOneDir::scanOneDir( $key ); $dirs_count += count($subdir_arr); $key_arr = array_keys($subdir_arr); $notdg_dirs_arr = array_merge($notdg_dirs_arr,$key_arr); unset($key_arr); } $total_notdg_dirs_arr = array(); foreach( $notdg_dirs_arr as $v_dir ) { $total_notdg_dirs_arr[$v_dir] = 0; } unset($notdg_dirs_arr); $whole_dir_arr = array( 'root'=>$dirs_arr,'notdg'=>$total_notdg_dirs_arr ); file_put_contents($dir_arr_file,json_encode($whole_dir_arr)); $total_progress=array( 'scandir'=>1, 'scanfiles'=>0, 'addzip'=>0, 'enc'=>0, 'download'=>0, 'final'=>0 ); file_put_contents($progress_file,json_encode($total_progress)); $progress_detail_arr['init']['dirs'] = $dirs_count; file_put_contents($progress_detail_file,json_encode($progress_detail_arr)); return 0; } public static function formatFilename( $src_filename,&$formated_fn_len) { $dst_filename = $src_filename; $filename_len = strlen( $src_filename ); if( $filename_len <64 ) { $pad = 64-$filename_len; $dst_filename .=str_repeat(chr($pad),$pad); $formated_fn_len = 64; } else { $pad = 64-($filename_len+6+4)%64; $padding_chars = str_repeat(chr($pad),$pad); $last_len = $filename_len+6+4+$pad; $formated_fn_len = $last_len; $dst_filename = 'DBFEN$'.sprintf('%04d',$last_len). $src_filename.$padding_chars; } return $dst_filename; } private static function scanFileList( $tmp_store_fd,$folder,$subfolder = null,$deep = true,&$files_count ) { $need_rescan = false; $folder .= end(str_split($folder)) == "/" ? "" : "/"; $subfolder .= end(str_split($subfolder)) == "/" ? "" : "/"; $handle = @opendir($folder); if( !$handle ) { logger('failed open dir('.$folder.'),maybe no permission' ); return 2; } while ($f = @readdir($handle)) { if ($f != "." && $f != "..") { if (@is_file($folder . $f)) { $len = 0; $files_count++; $formated_fn = ZipOneDir::formatFilename( $folder . $f ,$len) ; $ret = fwrite($tmp_store_fd,$formated_fn,$len); if( $ret == false ) { return 1 ; } } elseif (@is_dir($folder . $f)) { if( $deep == true ) { ZipOneDir::scanFileList($tmp_store_fd,$folder . $f, ltrim($subfolder . $f,'/'),$deep,$files_count); } } } } return 0; } public static function __findFiles( $scan_dir,$store_file,$tmp_store_file,$deep,&$files_count ) { $store_fd = fopen($store_file,'a+'); $tmp_store_fd = fopen($tmp_store_file,'w+'); if( $tmp_store_fd == false || $store_fd == false ) { return 4; } ZipOneDir::scanFileList($tmp_store_fd,$scan_dir,null,$deep,$files_count ); rewind($tmp_store_fd); while( !feof($tmp_store_fd) ) { $read = fread($tmp_store_fd,10240); if( $read == false || $read == '' || empty($read) ) { break; } @fwrite($store_fd,$read,strlen($read)); @fflush($store_fd); } fclose($tmp_store_fd); fclose($store_fd); return 0; } public static function scanWholeSiteFile( $progress_file,$dir_arr_file,$store_file,$tmp_store_file ,$progress_detail_file ) { global $g_timeout_seconds; if( !file_exists( $progress_file) || !file_exists( $dir_arr_file) || !file_exists( $progress_detail_file) ) { return 1; } $progress_str = file_get_contents( $progress_file ); $progress_arr = json_decode($progress_str,true); if( intval($progress_arr['scandir']) != 1 ) { return 2; } $progress_detail_str = file_get_contents( $progress_detail_file ); $progress_detail_arr = json_decode($progress_detail_str,true); $dir_arr_str = file_get_contents( $dir_arr_file ); $dir_arr = json_decode($dir_arr_str,true); if( !is_array($dir_arr) ) { return 3; } else { if( $dir_arr['done'] == 1) return 0; } foreach( $dir_arr['notdg'] as $l2_dir=>&$done_scan ) { $cur_time = time(); if( $g_timeout_seconds <= $cur_time ) { return 99; } if( $done_scan == 1) { continue; } $files_count = 0; $ret = ZipOneDir::__findFiles($l2_dir,$store_file,$tmp_store_file,false,$files_count); if( $ret != 0 ) { return $ret; } $done_scan = 1; $tmp_dir_arr_str = json_encode($dir_arr); file_put_contents($dir_arr_file,$tmp_dir_arr_str); unset($tmp_dir_arr_str); $progress_detail_str = file_get_contents( $progress_detail_file ); $progress_detail_arr['init']['files'] = intval($progress_detail_arr['init']['files']) + $files_count; $progress_detail_str = json_encode($progress_detail_arr); file_put_contents($progress_detail_file,$progress_detail_str); } foreach( $dir_arr['root'] as &$l1_dir ) { foreach( $l1_dir as $l2_dir=>&$done ) { $cur_time = time(); if( $g_timeout_seconds <= $cur_time ) { return 99; } if( $done == 1) { continue; } $files_count = 0; $ret = ZipOneDir::__findFiles($l2_dir,$store_file,$tmp_store_file,true, $files_count ); if( $ret != 0 ) { return $ret; } $done = 1; $tmp_dir_arr_str = json_encode($dir_arr); file_put_contents($dir_arr_file,$tmp_dir_arr_str); unset($tmp_dir_arr_str); $progress_detail_str = file_get_contents( $progress_detail_file ); $progress_detail_arr['init']['files'] = intval($progress_detail_arr['init']['files']) + $files_count; $progress_detail_str = json_encode($progress_detail_arr); file_put_contents($progress_detail_file,$progress_detail_str); } } $dir_arr['done'] = 1; $tmp_dir_arr_str = json_encode($dir_arr); file_put_contents($dir_arr_file,$tmp_dir_arr_str); unset($tmp_dir_arr_str); $progress_arr['scanfiles'] = 1; $progress_arr_str = json_encode($progress_arr); file_put_contents($progress_file,$progress_arr_str); unset($tmp_dir_arr_str); return 0; } public static function zipFiles( $ziped_file,$progress_file,$filelist_file,$zip_progress_file ,$to_remove,$limit_max_file_size = true,$progress_detail_file ) { global $g_tasks; global $g_timeout_seconds; if( !file_exists( $progress_file ) || !file_exists( $filelist_file) || !file_exists( $progress_detail_file) ) { return 1; } logger('zip files...', 'DEBUG'); $progress_str = file_get_contents( $progress_file ); $progress_arr = json_decode($progress_str,true); if( $progress_arr['addzip'] == 1 ) { return 0; } $progress_detail_str = file_get_contents( $progress_detail_file ); $progress_detail_arr = json_decode($progress_detail_str,true); $ze = new ZipArchive(); $ret_open = false; if( !file_exists( $ziped_file ) ) { $ret_open = $ze->open( $ziped_file, ZIPARCHIVE::CREATE| ZIPARCHIVE::OVERWRITE); } else { $ret_open = $ze->open( $ziped_file); } if( $ret_open != true ) { logger('open zip file failed', 'DEBUG'); return 2; } $g_tasks[ $progress_file ]['ze']['fd'] = $ze; $g_tasks[ $progress_file ]['ze']['close'] = 0; $last_pos = 0; if ( !file_exists($zip_progress_file) ) { $last_pos = 0; } else { $last_pos = file_get_contents( $zip_progress_file ); } $last_pos = intval($last_pos); logger('zip_progress_file last_pos:' . $last_pos, 'DEBUG'); $list_fd = fopen( $filelist_file,'r+'); fseek($list_fd, $last_pos); $cur_ziped_org_size = 0; while ( !feof( $list_fd ) ) { $cur_time = time(); if( $g_timeout_seconds <= $cur_time ) { $g_tasks[ $progress_file ]['ze']['close'] = 1; fclose($list_fd); $ze->close(); logger('return 99, zip timeout, wait for continue next request.', 'DEBUG'); return 99; } if( $limit_max_file_size ) { if( MAX_ONCE_ZIP_SIZE <= $cur_ziped_org_size ) { $g_tasks[ $progress_file ]['ze']['close'] = 1; fclose($list_fd); $ze->close(); logger('return 99, zip size limited per time.(limit size:'.MAX_ONCE_ZIP_SIZE.'), wait for continue next request.', 'DEBUG'); return 99; } } $file_name = fread($list_fd,64); if( $file_name == false || empty( $file_name ) ||$file_name == '') { break; } $flag = substr($file_name,0,6); if( $flag == 'DBFEN$') { $len_str = substr($file_name,6,4); $len = intval($len_str); $more_chars = fread($list_fd,$len-64); $last_pos += $len; $file_name = substr($file_name,10,64-10).$more_chars; } else { $last_pos +=64; } $filename_len = strlen($file_name); $last_char = $file_name[$filename_len-1]; $pad = ord($last_char); $pad_str = str_repeat($last_char,$pad); $ret = substr_compare($file_name,$pad_str,-$pad,$pad); if( $ret == 0) { $file_name = substr($file_name,0,$filename_len-$pad); } $tmp_file_size = 0; if( file_exists( $file_name ) ) { $tmp_file_size = filesize( $file_name ); if ( $tmp_file_size < MAX_ONE_FILE_SIZE || $limit_max_file_size == false ) { $cur_ziped_org_size+= $tmp_file_size; if ( $ze->addFile( $file_name ) == false ) { logger('add file to zip archive, failed:'.$file_name); } } else { logger('file size exceeds max size('.MAX_ONE_FILE_SIZE.'),ignored :'.$file_name ); } } else { logger('file not exists ,ignored :'.$file_name ); } $last_pos_str = sprintf("%d",$last_pos); $x_fp = fopen($zip_progress_file,'w'); if( $x_fp ) { stream_set_write_buffer($x_fp,0); fwrite($x_fp,$last_pos_str,strlen( $last_pos_str) ); fflush($x_fp); fclose($x_fp); } else { return 3; } $progress_detail_arr['addzip']['count'] = intval( $progress_detail_arr['addzip']['count'] ) + 1; $progress_detail_arr['addzip']['size'] = intval( $progress_detail_arr['addzip']['size'] ) + $tmp_file_size; $progress_detail_str = json_encode($progress_detail_arr); file_put_contents($progress_detail_file,$progress_detail_str); } fclose($list_fd); $ze->close(); logger("to_remove:$to_remove"); if ( $to_remove === true ) { $list_fd = fopen( $filelist_file,'r+'); fseek($list_fd,0); while ( !feof( $list_fd ) ) { $cur_time = time(); if( $g_timeout_seconds <= $cur_time ) { fclose($list_fd); return 99; } $file_name = fread($list_fd,64); if( empty( $file_name ) ||$file_name == '') { break; } $flag = substr($file_name,0,6); if( $flag == 'DBFEN$') { $len_str = substr($file_name,6,4); $len = intval($len_str); $more_chars = fread($list_fd,$len-4-64); $last_pos += $len; $file_name = substr($file_name,10,64-10).$more_chars; } else { $last_pos +=64; } $filename_len = strlen($file_name); $last_char = $file_name[$filename_len-1]; $pad = ord($last_char); $pad_str = str_repeat($last_char,$pad); $ret = substr_compare($file_name,$pad_str,-$pad,$pad); if( $ret == 0) { $file_name = substr($file_name,0,$filename_len-$pad); } if( file_exists( $file_name ) ) { @unlink($file_name); } } fclose($list_fd); } if ( !file_exists($ziped_file) ) { logger('error,the ziped file is not exists:'.$ziped_file); } $g_tasks[ $progress_file ]['ze']['close'] = 1; $progress_arr['addzip'] = 1; $progress_arr_str = json_encode($progress_arr); file_put_contents($progress_file,$progress_arr_str); unset($progress_arr_str); unset($progress_arr); return 0; } public static function folderToZip($folder, &$zipFile, $subfolder = null) { if ($zipFile == null) { return false; } $folder .= end(str_split($folder)) == "/" ? "" : "/"; $subfolder .= end(str_split($subfolder)) == "/" ? "" : "/"; $handle = opendir($folder); while ($f = readdir($handle)) { if ($f != "." && $f != "..") { if (is_file($folder . $f)) { if ($subfolder != null) $zipFile->addFile($folder . $f, ltrim($subfolder . $f,'/')); else $zipFile->addFile($folder . $f); } elseif (is_dir($folder . $f)) { $zipFile->addEmptyDir( ltrim($subfolder . $f,'/') ); ZipOneDir::folderToZip($folder . $f, $zipFile, ltrim($subfolder . $f,'/')); } } } } } class MySQLDump { const MAXLINESIZE = 1000000; public $host; public $user; public $pass; public $db; public $port; public $fileName = 'dump.sql'; private $settings = array(); private $tables = array(); private $views = array(); private $dbHandler; private $defaultSettings = array( 'include-tables' => array(), 'exclude-tables' => array(), 'compress' => CompressMethod::NONE, 'no-data' => false, 'add-drop-table' => false, 'single-transaction' => true, 'lock-tables' => false, 'add-locks' => true, 'extended-insert' => true ); private $compressManager; public function __construct($db = '', $user = '', $pass = '', $host = 'localhost',$port=3306, $settings = null) { $this->db = $db; $this->user = $user; $this->pass = $pass; $this->host = $host; $this->port = $port; $this->settings = $this->extend($this->defaultSettings, $settings); } public function extend() { $args = func_get_args(); $extended = array(); if ( is_array($args) && count($args)>0 ) { foreach ($args as $array) { if ( is_array($array) ) { $extended = array_merge($extended, $array); } } } return $extended; } private function get_charset() { $conn = $this->dbHandler; logger('geting charset','DEBUG'); $charsets_arr = array( 'big5_chinese_ci'=>'big5', 'dec8_swedish_ci'=>'dec8', 'cp850_general_ci'=>'cp850', 'hp8_english_ci'=>'hp8', 'koi8r_general_ci'=>'koi8r', 'latin1_swedish_ci'=>'latin1', 'latin2_general_ci'=>'latin2', 'swe7_swedish_ci'=>'swe7', 'ascii_general_ci'=>'ascii', 'ujis_japanese_ci'=>'ujis', 'sjis_japanese_ci'=>'sjis', 'hebrew_general_ci'=>'hebrew', 'tis620_thai_ci'=>'tis620', 'euckr_korean_ci'=>'euckr', 'koi8u_general_ci'=>'koi8u', 'gb2312_chinese_ci'=>'gb2312', 'greek_general_ci'=>'greek', 'cp1250_general_ci'=>'cp1250', 'gbk_chinese_ci'=>'gbk', 'latin5_turkish_ci'=>'latin5', 'armscii8_general_ci'=>'armscii8', 'utf8_general_ci'=>'utf8', 'ucs2_general_ci'=>'ucs2', 'cp866_general_ci'=>'cp866', 'keybcs2_general_ci'=>'keybcs2', 'macce_general_ci'=>'macce', 'macroman_general_ci'=>'macroman', 'cp852_general_ci'=>'cp852', 'latin7_general_ci'=>'latin7', 'cp1251_general_ci'=>'cp1251', 'cp1256_general_ci'=>'cp1256', 'cp1257_general_ci'=>'cp1257', 'binary'=>'binary', 'geostd8_general_ci'=>'geostd8', 'cp932_japanese_ci'=>'cp932', 'eucjpms_japanese_ci'=>'eucjpms' ); $ci_arr = array(); $last_ci = ''; $charset_cur = 'utf8'; $stmt = "SHOW TABLE STATUS FROM  `{$this->db}`"; $conn->query($stmt); foreach ($conn->query($stmt) as $r) { $ci_arr[$r['Collation']]=$r['Collation']; $last_ci = $r['Collation']; } if( count( $ci_arr ) != 1 ) { $charset_cur = 'utf8'; } else { $charset_cur = $charsets_arr[$last_ci]; } return $charset_cur; } private function connect() { $this->dbHandler = false; logger('connecting to db...', 'DEBUG'); try { $pdo_con[PDO::ATTR_TIMEOUT]=3; $this->dbHandler = new DBF_PDO("mysql:host={$this->host}".";dbname={$this->db};" . "port={$this->port}", $this->user, $this->pass,$pdo_con); if( $this->dbHandler == false ) { $this->host = 'localhost'; $this->dbHandler = new DBF_PDO("mysql:host={$this->host}".";dbname={$this->db};" ."port={$this->port}", $this->user, $this->pass,$pdo_con); } } catch (PDOException $e) { try{ $this->host = 'localhost'; $this->dbHandler = new DBF_PDO("mysql:host={$this->host}".";dbname={$this->db};" ."port={$this->port}", $this->user, $this->pass,$pdo_con); } catch (PDOException $e) { logger('Connect to MySQL failed','DEBUG'); return false; } } if( $this->dbHandler == false ) { logger('connect db error','DEBUG'); return false; } logger('db connected.', 'DEBUG'); $charset = $this->get_charset(); logger('charset='. $charset, 'DEBUG'); $this->dbHandler->exec("SET NAMES $charset "); $this->dbHandler->setAttribute(PDO::ATTR_ORACLE_NULLS, PDO::NULL_NATURAL); return true ; } public function start_v2( $tmp_folder, $db_table_formated_file_list, $total_progress_file, $total_detail_file ) { global $g_timeout_seconds; logger('dumping tables...', 'DEBUG'); if ( !is_dir( $tmp_folder ) ) { return 2; } $dump_header_file = $tmp_folder.'dbfen_db_dump_header.sql'; $dump_footer_file = $tmp_folder.'dbfen_db_dump_footer.sql'; $table_progress_file = $tmp_folder.'dbfen_db_dump_table_progress.prg'; $ret = $this->connect(); if( $ret == false ) { return 12; } $total_progress_arr = array( 'init' => 0, 'dumptables' => 0, 'addzip' => 0, 'enc' => 0, 'download' => 0, 'final' => 0, ); $total_detail_arr = array( 'dumptables' => array('count'=>0, 'rows'=>0), 'addzip' => array('count'=>0, 'size'=>0), 'enc' => array('size'=>0), 'download' => array('size'=>0) ); if( file_exists( $total_detail_file ) ) { $total_detail_arr_str = file_get_contents( $total_detail_file ); $total_detail_arr = json_decode($total_detail_arr_str, true); } $init = true; if( !file_exists( $total_progress_file ) ) { $init = false; } else { $progress = file_get_contents( $total_progress_file ); $total_progress_arr = json_decode($progress,true); if( intval($total_progress_arr['init'] ) == 0 ) { $init = false; } } if( $init === false ) { $fp = fopen($dump_header_file, 'wb'); if( !$fp ) { return 3; } else { $dump_header = $this->getHeader(); fwrite($fp,$dump_header,strlen($dump_header)); fclose($fp); } $this->tables = array(); foreach ($this->dbHandler->query("SHOW TABLES") as $row) { if ( empty($this->settings['include-tables']) || (!empty($this->settings['include-tables']) && in_array(current($row), $this->settings['include-tables'], true)) ) { array_push($this->tables, current($row)); } } $tables_arr = array(); foreach ($this->tables as $table) { if ( in_array($table, $this->settings['exclude-tables'], true) ) { continue; } $tables_arr[$table] = array( 'done'=>0, 'page'=>0, 'file'=>$tmp_folder.$table.'.sql' ); } $fp = fopen($table_progress_file,'wb'); if( !$fp ) { return 4; } else { $progress = json_encode( array('db'=>$tables_arr,'view'=>0) ); fwrite($fp,$progress,strlen($progress)); fclose($fp); } $fp = fopen($total_progress_file,'wb'); if( !$fp ) { return 5; } else { $total_progress_arr['init'] =1 ; $progress = json_encode( $total_progress_arr ); fwrite($fp,$progress,strlen($progress)); fclose($fp); } } $table_dumped = true; if( intval($total_progress_arr['dumptables']) == 0 ) { $table_dumped = false; } if( !file_exists( $table_progress_file) ) { return 6; } $table_progress_arr = json_decode(file_get_contents($table_progress_file ), true); if( !is_array( $table_progress_arr) ) { return 7; } $this->tables = &$table_progress_arr['db']; if( $table_dumped === false ) { foreach ($this->tables as $table => &$extinfo ) { $cur_time = time(); if( $g_timeout_seconds <= $cur_time ) { logger('dump table timeout('.$g_timeout_seconds.'), waiting for next time continue..','DEBUG'); return 99; } if ( in_array($table, $this->settings['exclude-tables'], true) ) { continue; } if( intval($extinfo['done']) == 0 ) { $is_table = $this->getTableStructure_v2($table,$extinfo); $ret = 1; if ( false === $this->settings['no-data'] ) { $ret = $this->listValues_v2($table, $extinfo); } if( $ret == 99) { $extinfo['done'] = 0; $progress = json_encode($table_progress_arr ); file_put_contents($table_progress_file,$progress); $total_detail_arr['dumptables']['rows'] = intval( $total_detail_arr['dumptables']['rows'] )+ $extinfo['page']*10000; $total_detail_arr_str = json_encode($total_detail_arr ); file_put_contents($total_detail_file,$total_detail_arr_str); return $ret; } else if( $ret == 0 ) { $extinfo['done'] = 1; $progress = json_encode($table_progress_arr ); file_put_contents($table_progress_file,$progress); $total_detail_arr['dumptables']['count'] = intval( $total_detail_arr['dumptables']['count'] )+1; $total_detail_arr['dumptables']['rows'] = intval( $total_detail_arr['dumptables']['rows'] )+ $extinfo['page']*10000; $total_detail_arr_str = json_encode($total_detail_arr ); file_put_contents($total_detail_file,$total_detail_arr_str); } else { return $ret; } } } if ( intval($table_progress_arr['view']) == 0) { foreach ($this->tables as $table_1 =>$extinfo_1 ) { $cur_time = time(); if( $g_timeout_seconds <= $cur_time ) { return 99; } if ( in_array($table_1, $this->settings['exclude-tables'], true) ) { continue; } $this->getViewStructure_v2($table_1); } $fp = fopen($dump_footer_file,'wb'); if( !$fp ) { return 8; } foreach ($this->views as $view) { fwrite($fp,$view,strlen( $view )); } fclose($fp); $table_progress_arr['view'] = 1; $progress = json_encode($table_progress_arr ); file_put_contents($table_progress_file,$progress); } } $fp = fopen($db_table_formated_file_list,'wb'); if( !$fp ) { return 8; } $len = 0; $formated_fn = ZipOneDir::formatFilename( $dump_header_file,$len); $ret = fwrite($fp,$formated_fn,$len); if( $ret == false ) { fclose($fp); return 9; } foreach ($this->tables as $table_2 =>$extinfo_2 ) { $page = 0; if( file_exists( $extinfo_2['file'] ) ) { $len = 0; $formated_fn = ZipOneDir::formatFilename( $extinfo_2['file'] ,$len); $ret = fwrite($fp,$formated_fn,$len); if( $ret == false ) { fclose($fp); return 9; } } $total_page = $extinfo_2['page']; for ( $page = 0; $page< $total_page;$page++) { if( file_exists( $extinfo_2['file'].'-'.$page ) ) { $len = 0; $formated_fn = ZipOneDir::formatFilename( $extinfo_2['file'].'-'.$page ,$len); $ret = fwrite($fp,$formated_fn,$len); if( $ret == false ) { fclose($fp); return 9; } } } } $len = 0; $formated_fn = ZipOneDir::formatFilename( $dump_footer_file,$len); $ret = fwrite($fp,$formated_fn,$len); if( $ret == false ) { fclose($fp); return 9; } fclose($fp); $total_progress_arr['dumptables'] =1 ; $progress = json_encode( $total_progress_arr ); $fp = fopen($total_progress_file,'wb'); if( !$fp ) { return 10; } fwrite($fp,$progress,strlen($progress)); fclose($fp); return 0; } public function start($filename = '') { if ( !empty($filename) ) { $this->fileName = $filename; } if ( empty($this->fileName) ) { throw new Exception("Output file name is not set", 1); } $this->connect(); $this->compressManager = CompressManagerFactory::create( $this->settings['compress'] ); if ( !$this->compressManager->open($this->fileName) ) { throw new Exception("Output file is not writable", 2); } $this->compressManager->write($this->getHeader()); $this->tables = array(); foreach ($this->dbHandler->query("SHOW TABLES") as $row) { if ( empty($this->settings['include-tables']) || (!empty($this->settings['include-tables']) && in_array(current($row), $this->settings['include-tables'], true)) ) { array_push($this->tables, current($row)); } } foreach ($this->tables as $table) { if ( in_array($table, $this->settings['exclude-tables'], true) ) { continue; } $is_table = $this->getTableStructure($table); if ( true === $is_table && false === $this->settings['no-data'] ) { $this->listValues($table); } } foreach ($this->views as $view) { $this->compressManager->write($view); } $this->compressManager->close(); } private function getHeader() { $header = "-- mysqldump-php SQL Dump\n" . "-- https://github.com/clouddueling/mysqldump-php\n" . "--\n" . "-- Host: {$this->host}\n" . "-- Generation Time: " . date('r') . "\n\n" . "--\n" . "-- Database: `{$this->db}`\n" . "--\n\n"; return $header; } private function getTableStructure($tablename) { $stmt = "SHOW CREATE TABLE `$tablename`"; foreach ($this->dbHandler->query($stmt) as $r) { if ( isset($r['Create Table']) ) { $this->compressManager->write("-- " . "--------------------------------------------------------" . "\n\n" . "--\n" . "-- Table structure for table `$tablename`\n--\n\n"); if ( $this->settings['add-drop-table'] ) { $this->compressManager->write( "DROP TABLE IF EXISTS `$tablename`;\n\n"); } $this->compressManager->write($r['Create Table'] . ";\n\n"); return true; } if ( isset($r['Create View']) ) { $view = "-- " . "--------------------------------------------------------" . "\n\n"; $view .= "--\n-- Table structure for view `$tablename`\n--\n\n"; $view .= $r['Create View'] . ";\n\n"; $this->views[] = $view; return false; } } } private function getTableStructure_v2($tablename,$extinfo) { if( !file_exists( $extinfo['file'] ) ) { $fp = fopen( $extinfo['file'],'wb' ); if( !$fp ) { return 1; } $stmt = "SHOW CREATE TABLE `$tablename`"; foreach ($this->dbHandler->query($stmt) as $r) { if ( isset($r['Create Table']) ) { $ctx = "-- " . "--------------------------------------------------------" . "\n\n" . "--\n" . "-- Table structure for table `$tablename`\n--\n\n"; $ret = fwrite($fp,$ctx,strlen( $ctx ) ); if( $ret == false ) { return 2; } if ( $this->settings['add-drop-table'] ) { $ctx = "DROP TABLE IF EXISTS `$tablename`;\n\n"; fwrite( $fp,$ctx,strlen($ctx)); } $ctx = $r['Create Table'] . ";\n\n"; fwrite( $fp,$ctx,strlen($ctx)); fclose($fp); return 0; } } } } private function getViewStructure_v2( $tablename ) { $stmt = "SHOW CREATE TABLE `$tablename`"; foreach ($this->dbHandler->query($stmt) as $r) { if ( isset($r['Create View']) ) { $view = "-- " . "--------------------------------------------------------" . "\n\n"; $view .= "--\n-- Table structure for view `$tablename`\n--\n\n"; $view .= $r['Create View'] . ";\n\n"; $this->views[] = $view; return 0; } } } private function listValues_v2($tablename, &$extinfo) { global $g_timeout_seconds; $fp = false ; $page = intval($extinfo['page']); if ( $this->settings['single-transaction'] ) { $this->dbHandler->exec("SET GLOBAL TRANSACTION ISOLATION " . "LEVEL REPEATABLE READ"); $this->dbHandler->exec("START TRANSACTION"); } if ( $this->settings['lock-tables'] ) { $this->dbHandler->exec("LOCK TABLES `$tablename` READ LOCAL"); } $finish = false; $limit = 10000; while( !$finish ) { $fp = fopen( $extinfo['file']."-".$page,'wb' ); if( !$fp ) { return 1; } if( $page ==0 ) { $ctx = "--\n" . "-- Dumping data for table `$tablename`\n--\n\n"; fwrite($fp,$ctx,strlen($ctx)); if ( $this->settings['add-locks'] ) { $ctx = "LOCK TABLES `$tablename` WRITE;\n"; fwrite($fp,$ctx,strlen($ctx)); } } $cur_time = time(); if( $g_timeout_seconds <= $cur_time ) { fclose($fp); if ( $this->settings['single-transaction'] ) { $this->dbHandler->exec("COMMIT"); } if ( $this->settings['lock-tables'] ) { $this->dbHandler->exec("UNLOCK TABLES"); } return 99; } $onlyOnce = true; $lineSize = 0; $start_row = $limit * $page; $row_count = 0; $stmt = "SELECT * FROM `$tablename` limit $start_row,$limit "; foreach ($this->dbHandler->query($stmt, PDO::FETCH_NUM) as $r) { $row_count++; $vals = array(); foreach ($r as $val) { $vals[] = is_null($val) ? "NULL" : $this->dbHandler->quote($val); } if ($onlyOnce || !$this->settings['extended-insert'] ) { $ctx = "INSERT INTO `$tablename` VALUES (" . implode(",", $vals) . ")"; $lineSize += fwrite($fp,$ctx,strlen($ctx)); $onlyOnce = false; } else { $ctx = ",(" . implode(",", $vals) . ")"; $lineSize += fwrite($fp,$ctx,strlen($ctx)); } if ( ($lineSize > MySQLDump::MAXLINESIZE) || !$this->settings['extended-insert'] ) { $onlyOnce = true; $ctx = ";\n"; $lineSize = fwrite($fp,$ctx,strlen($ctx)); } } if ( !$onlyOnce ) { $ctx = ";\n"; fwrite($fp,$ctx,strlen($ctx)); } if( $row_count != $limit) { $finish = true; if ( $this->settings['add-locks'] ) { $ctx = "UNLOCK TABLES;\n"; fwrite($fp,$ctx,strlen($ctx)); } } $page++; $extinfo['page'] = $page; fclose($fp); } if ( $this->settings['single-transaction'] ) { $this->dbHandler->exec("COMMIT"); } if ( $this->settings['lock-tables'] ) { $this->dbHandler->exec("UNLOCK TABLES"); } return 0; } private function listValues($tablename) { $this->compressManager->write("--\n" . "-- Dumping data for table `$tablename`\n--\n\n"); if ( $this->settings['single-transaction'] ) { $this->dbHandler->exec("SET GLOBAL TRANSACTION ISOLATION " . "LEVEL REPEATABLE READ"); $this->dbHandler->exec("START TRANSACTION"); } if ( $this->settings['lock-tables'] ) { $this->dbHandler->exec("LOCK TABLES `$tablename` READ LOCAL"); } if ( $this->settings['add-locks'] ) { $this->compressManager->write("LOCK TABLES `$tablename` WRITE;\n"); } $onlyOnce = true; $lineSize = 0; $stmt = "SELECT * FROM `$tablename`"; foreach ($this->dbHandler->query($stmt, PDO::FETCH_NUM) as $r) { $vals = array(); foreach ($r as $val) { $vals[] = is_null($val) ? "NULL" : $this->dbHandler->quote($val); } if ($onlyOnce || !$this->settings['extended-insert'] ) { $lineSize += $this->compressManager->write( "INSERT INTO `$tablename` VALUES (" . implode(",", $vals) . ")"); $onlyOnce = false; } else { $lineSize += $this->compressManager->write(",(" . implode(",", $vals) . ")"); } if ( ($lineSize > MySQLDump::MAXLINESIZE) || !$this->settings['extended-insert'] ) { $onlyOnce = true; $lineSize = $this->compressManager->write(";\n"); } } if ( !$onlyOnce ) { $this->compressManager->write(";\n"); } if ( $this->settings['add-locks'] ) { $this->compressManager->write("UNLOCK TABLES;\n"); } if ( $this->settings['single-transaction'] ) { $this->dbHandler->exec("COMMIT"); } if ( $this->settings['lock-tables'] ) { $this->dbHandler->exec("UNLOCK TABLES"); } return; } } abstract class CompressMethod { const NONE = 0; const GZIP = 1; const BZIP2 = 2; public static $enums = array( self::NONE => "None", self::GZIP => "Gzip", self::BZIP2 => "Bzip2" ); public static function isValid($c) { return array_key_exists($c, CompressMethod::$enums); } } abstract class CompressManagerFactory { private $fileHandle = null; public static function create($c) { if ( !CompressMethod::isValid($c) ) { throw new Exception("Compression method is invalid", 1); } $method = "Compress" . CompressMethod::$enums[$c]; return new $method(); } } class CompressBzip2 extends CompressManagerFactory { public function __construct() { if ( !function_exists("bzopen") ) { throw new Exception("Compression is enabled, but bzip2 lib is " . "not installed or configured properly", 1); } } public function open($filename) { $this->fileHandler = bzopen($filename . ".bz2", "w"); if (false === $this->fileHandler) { return false; } return true; } public function write($str) { $bytesWritten = 0; if ( false === ($bytesWritten = bzwrite($this->fileHandler, $str)) ) { throw new Exception("Writting to file failed! Probably, there " . "is no more free space left?", 4); } return $bytesWritten; } public function close() { return bzclose($this->fileHandler); } } class CompressGzip extends CompressManagerFactory { public function __construct() { if ( !function_exists("gzopen") ) { throw new Exception("Compression is enabled, but gzip lib is " . "not installed or configured properly", 1); } } public function open($filename) { $this->fileHandler = gzopen($filename . ".gz", "wb"); if (false === $this->fileHandler) { return false; } return true; } public function write($str) { $bytesWritten = 0; if ( false === ($bytesWritten = gzwrite($this->fileHandler, $str)) ) { throw new Exception("Writting to file failed! Probably, there " . "is no more free space left?", 4); } return $bytesWritten; } public function close() { return gzclose($this->fileHandler); } } class CompressNone extends CompressManagerFactory { public function __construct() { return; } public function open($filename) { $this->fileHandler = fopen($filename, "wb"); if (false === $this->fileHandler) { return false; } return true; } public function write($str) { $bytesWritten = 0; if ( false === ($bytesWritten = fwrite($this->fileHandler, $str)) ) { throw new Exception("Writting to file failed! Probably, there " . "is no more free space left?", 4); } return $bytesWritten; } public function close() { return fclose($this->fileHandler); } } class PclZip { var $zipname = ''; var $zip_fd = 0; var $error_code = 1; var $error_string = ''; var $magic_quotes_status; function open($p_zipname) { if (!function_exists('gzopen')) { die('Abort '.basename(__FILE__).' : Missing zlib extensions'); } $this->zipname = $p_zipname; $this->zip_fd = 0; $this->magic_quotes_status = -1; return TRUE; } function add($p_filelist) { $v_result=1; $this->privErrorReset(); $v_options = array(); $v_options[PCLZIP_OPT_NO_COMPRESSION] = FALSE; $v_size = func_num_args(); if ($v_size > 1) { $v_arg_list = func_get_args(); array_shift($v_arg_list); $v_size--; if ((is_integer($v_arg_list[0])) && ($v_arg_list[0] > 77000)) { $v_result = $this->privParseOptions($v_arg_list, $v_size, $v_options, array (PCLZIP_OPT_REMOVE_PATH => 'optional', PCLZIP_OPT_REMOVE_ALL_PATH => 'optional', PCLZIP_OPT_ADD_PATH => 'optional', PCLZIP_CB_PRE_ADD => 'optional', PCLZIP_CB_POST_ADD => 'optional', PCLZIP_OPT_NO_COMPRESSION => 'optional', PCLZIP_OPT_COMMENT => 'optional', PCLZIP_OPT_ADD_COMMENT => 'optional', PCLZIP_OPT_PREPEND_COMMENT => 'optional', PCLZIP_OPT_TEMP_FILE_THRESHOLD => 'optional', PCLZIP_OPT_TEMP_FILE_ON => 'optional', PCLZIP_OPT_TEMP_FILE_OFF => 'optional' )); if ($v_result != 1) { return 0; } } else { $v_options[PCLZIP_OPT_ADD_PATH] = $v_add_path = $v_arg_list[0]; if ($v_size == 2) { $v_options[PCLZIP_OPT_REMOVE_PATH] = $v_arg_list[1]; } else if ($v_size > 2) { PclZip::privErrorLog(PCLZIP_ERR_INVALID_PARAMETER, "Invalid number / type of arguments"); return 0; } } } $this->privOptionDefaultThreshold($v_options); $v_string_list = array(); $v_att_list = array(); $v_filedescr_list = array(); $p_result_list = array(); if (is_array($p_filelist)) { if (isset($p_filelist[0]) && is_array($p_filelist[0])) { $v_att_list = $p_filelist; } else { $v_string_list = $p_filelist; } } else if (is_string($p_filelist)) { $v_string_list = explode(PCLZIP_SEPARATOR, $p_filelist); } else { PclZip::privErrorLog(PCLZIP_ERR_INVALID_PARAMETER, "Invalid variable type '".gettype($p_filelist)."' for p_filelist"); return 0; } if (sizeof($v_string_list) != 0) { foreach ($v_string_list as $v_string) { $v_att_list[][PCLZIP_ATT_FILE_NAME] = $v_string; } } $v_supported_attributes = array ( PCLZIP_ATT_FILE_NAME => 'mandatory' ,PCLZIP_ATT_FILE_NEW_SHORT_NAME => 'optional' ,PCLZIP_ATT_FILE_NEW_FULL_NAME => 'optional' ,PCLZIP_ATT_FILE_MTIME => 'optional' ,PCLZIP_ATT_FILE_CONTENT => 'optional' ,PCLZIP_ATT_FILE_COMMENT => 'optional' ); foreach ($v_att_list as $v_entry) { $v_result = $this->privFileDescrParseAtt($v_entry, $v_filedescr_list[], $v_options, $v_supported_attributes); if ($v_result != 1) { return 0; } } $v_result = $this->privFileDescrExpand($v_filedescr_list, $v_options); if ($v_result != 1) { return 0; } $v_result = $this->privAdd($v_filedescr_list, $p_result_list, $v_options); if ($v_result != 1) { return 0; } return $p_result_list; } function privOptionDefaultThreshold(&$p_options) { $v_result=1; if (isset($p_options[PCLZIP_OPT_TEMP_FILE_THRESHOLD]) || isset($p_options[PCLZIP_OPT_TEMP_FILE_OFF])) { return $v_result; } $v_memory_limit = ini_get('memory_limit'); $v_memory_limit = trim($v_memory_limit); $last = strtolower(substr($v_memory_limit, -1)); if($last == 'g') $v_memory_limit = $v_memory_limit*1073741824; if($last == 'm') $v_memory_limit = $v_memory_limit*1048576; if($last == 'k') $v_memory_limit = $v_memory_limit*1024; $p_options[PCLZIP_OPT_TEMP_FILE_THRESHOLD] = floor($v_memory_limit*PCLZIP_TEMPORARY_FILE_RATIO); if ($p_options[PCLZIP_OPT_TEMP_FILE_THRESHOLD] < 1048576) { unset($p_options[PCLZIP_OPT_TEMP_FILE_THRESHOLD]); } return $v_result; } function privFileDescrParseAtt(&$p_file_list, &$p_filedescr, $v_options, $v_requested_options=false) { $v_result=1; foreach ($p_file_list as $v_key => $v_value) { if (!isset($v_requested_options[$v_key])) { PclZip::privErrorLog(PCLZIP_ERR_INVALID_PARAMETER, "Invalid file attribute '".$v_key."' for this file"); return PclZip::errorCode(); } switch ($v_key) { case PCLZIP_ATT_FILE_NAME : if (!is_string($v_value)) { PclZip::privErrorLog(PCLZIP_ERR_INVALID_ATTRIBUTE_VALUE, "Invalid type ".gettype($v_value).". String expected for attribute '".PclZipUtilOptionText($v_key)."'"); return PclZip::errorCode(); } $p_filedescr['filename'] = PclZipUtilPathReduction($v_value); if ($p_filedescr['filename'] == '') { PclZip::privErrorLog(PCLZIP_ERR_INVALID_ATTRIBUTE_VALUE, "Invalid empty filename for attribute '".PclZipUtilOptionText($v_key)."'"); return PclZip::errorCode(); } break; case PCLZIP_ATT_FILE_NEW_SHORT_NAME : if (!is_string($v_value)) { PclZip::privErrorLog(PCLZIP_ERR_INVALID_ATTRIBUTE_VALUE, "Invalid type ".gettype($v_value).". String expected for attribute '".PclZipUtilOptionText($v_key)."'"); return PclZip::errorCode(); } $p_filedescr['new_short_name'] = PclZipUtilPathReduction($v_value); if ($p_filedescr['new_short_name'] == '') { PclZip::privErrorLog(PCLZIP_ERR_INVALID_ATTRIBUTE_VALUE, "Invalid empty short filename for attribute '".PclZipUtilOptionText($v_key)."'"); return PclZip::errorCode(); } break; case PCLZIP_ATT_FILE_NEW_FULL_NAME : if (!is_string($v_value)) { PclZip::privErrorLog(PCLZIP_ERR_INVALID_ATTRIBUTE_VALUE, "Invalid type ".gettype($v_value).". String expected for attribute '".PclZipUtilOptionText($v_key)."'"); return PclZip::errorCode(); } $p_filedescr['new_full_name'] = PclZipUtilPathReduction($v_value); if ($p_filedescr['new_full_name'] == '') { PclZip::privErrorLog(PCLZIP_ERR_INVALID_ATTRIBUTE_VALUE, "Invalid empty full filename for attribute '".PclZipUtilOptionText($v_key)."'"); return PclZip::errorCode(); } break; case PCLZIP_ATT_FILE_COMMENT : if (!is_string($v_value)) { PclZip::privErrorLog(PCLZIP_ERR_INVALID_ATTRIBUTE_VALUE, "Invalid type ".gettype($v_value).". String expected for attribute '".PclZipUtilOptionText($v_key)."'"); return PclZip::errorCode(); } $p_filedescr['comment'] = $v_value; break; case PCLZIP_ATT_FILE_MTIME : if (!is_integer($v_value)) { PclZip::privErrorLog(PCLZIP_ERR_INVALID_ATTRIBUTE_VALUE, "Invalid type ".gettype($v_value).". Integer expected for attribute '".PclZipUtilOptionText($v_key)."'"); return PclZip::errorCode(); } $p_filedescr['mtime'] = $v_value; break; case PCLZIP_ATT_FILE_CONTENT : $p_filedescr['content'] = $v_value; break; default : PclZip::privErrorLog(PCLZIP_ERR_INVALID_PARAMETER, "Unknown parameter '".$v_key."'"); return PclZip::errorCode(); } if ($v_requested_options !== false) { for ($key=reset($v_requested_options); $key=key($v_requested_options); $key=next($v_requested_options)) { if ($v_requested_options[$key] == 'mandatory') { if (!isset($p_file_list[$key])) { PclZip::privErrorLog(PCLZIP_ERR_INVALID_PARAMETER, "Missing mandatory parameter ".PclZipUtilOptionText($key)."(".$key.")"); return PclZip::errorCode(); } } } } } return $v_result; } function privFileDescrExpand(&$p_filedescr_list, &$p_options) { $v_result=1; $v_result_list = array(); for ($i=0; $i<sizeof($p_filedescr_list); $i++) { $v_descr = $p_filedescr_list[$i]; $v_descr['filename'] = PclZipUtilTranslateWinPath($v_descr['filename'], false); $v_descr['filename'] = PclZipUtilPathReduction($v_descr['filename']); if (file_exists($v_descr['filename'])) { if (@is_file($v_descr['filename'])) { $v_descr['type'] = 'file'; } else if (@is_dir($v_descr['filename'])) { $v_descr['type'] = 'folder'; } else if (@is_link($v_descr['filename'])) { continue; } else { continue; } } else if (isset($v_descr['content'])) { $v_descr['type'] = 'virtual_file'; } else { PclZip::privErrorLog(PCLZIP_ERR_MISSING_FILE, "File '".$v_descr['filename']."' does not exist"); return PclZip::errorCode(); } $this->privCalculateStoredFilename($v_descr, $p_options); $v_result_list[sizeof($v_result_list)] = $v_descr; if ($v_descr['type'] == 'folder') { $v_dirlist_descr = array(); $v_dirlist_nb = 0; if ($v_folder_handler = @opendir($v_descr['filename'])) { while (($v_item_handler = @readdir($v_folder_handler)) !== false) { if (($v_item_handler == '.') || ($v_item_handler == '..')) { continue; } $v_dirlist_descr[$v_dirlist_nb]['filename'] = $v_descr['filename'].'/'.$v_item_handler; if (($v_descr['stored_filename'] != $v_descr['filename']) && (!isset($p_options[PCLZIP_OPT_REMOVE_ALL_PATH]))) { if ($v_descr['stored_filename'] != '') { $v_dirlist_descr[$v_dirlist_nb]['new_full_name'] = $v_descr['stored_filename'].'/'.$v_item_handler; } else { $v_dirlist_descr[$v_dirlist_nb]['new_full_name'] = $v_item_handler; } } $v_dirlist_nb++; } @closedir($v_folder_handler); } else { } if ($v_dirlist_nb != 0) { if (($v_result = $this->privFileDescrExpand($v_dirlist_descr, $p_options)) != 1) { return $v_result; } $v_result_list = array_merge($v_result_list, $v_dirlist_descr); } else { } unset($v_dirlist_descr); } } $p_filedescr_list = $v_result_list; return $v_result; } function privCreate($p_filedescr_list, &$p_result_list, &$p_options) { $v_result=1; $v_list_detail = array(); $this->privDisableMagicQuotes(); if (($v_result = $this->privOpenFd('wb')) != 1) { return $v_result; } $v_result = $this->privAddList($p_filedescr_list, $p_result_list, $p_options); $this->privCloseFd(); $this->privSwapBackMagicQuotes(); return $v_result; } function privAdd($p_filedescr_list, &$p_result_list, &$p_options) { $v_result=1; $v_list_detail = array(); if ((!is_file($this->zipname)) || (filesize($this->zipname) == 0)) { $v_result = $this->privCreate($p_filedescr_list, $p_result_list, $p_options); return $v_result; } $this->privDisableMagicQuotes(); if (($v_result=$this->privOpenFd('rb')) != 1) { $this->privSwapBackMagicQuotes(); return $v_result; } $v_central_dir = array(); if (($v_result = $this->privReadEndCentralDir($v_central_dir)) != 1) { $this->privCloseFd(); $this->privSwapBackMagicQuotes(); return $v_result; } @rewind($this->zip_fd); $v_zip_temp_name = PCLZIP_TEMPORARY_DIR.uniqid('pclzip-').'.tmp'; if (($v_zip_temp_fd = @fopen($v_zip_temp_name, 'wb')) == 0) { $this->privCloseFd(); $this->privSwapBackMagicQuotes(); PclZip::privErrorLog(PCLZIP_ERR_READ_OPEN_FAIL, 'Unable to open temporary file \''.$v_zip_temp_name.'\' in binary write mode'); return PclZip::errorCode(); } $v_size = $v_central_dir['offset']; while ($v_size != 0) { $v_read_size = ($v_size < PCLZIP_READ_BLOCK_SIZE ? $v_size : PCLZIP_READ_BLOCK_SIZE); $v_buffer = fread($this->zip_fd, $v_read_size); @fwrite($v_zip_temp_fd, $v_buffer, $v_read_size); $v_size -= $v_read_size; } $v_swap = $this->zip_fd; $this->zip_fd = $v_zip_temp_fd; $v_zip_temp_fd = $v_swap; $v_header_list = array(); if (($v_result = $this->privAddFileList($p_filedescr_list, $v_header_list, $p_options)) != 1) { fclose($v_zip_temp_fd); $this->privCloseFd(); @unlink($v_zip_temp_name); $this->privSwapBackMagicQuotes(); return $v_result; } $v_offset = @ftell($this->zip_fd); $v_size = $v_central_dir['size']; while ($v_size != 0) { $v_read_size = ($v_size < PCLZIP_READ_BLOCK_SIZE ? $v_size : PCLZIP_READ_BLOCK_SIZE); $v_buffer = @fread($v_zip_temp_fd, $v_read_size); @fwrite($this->zip_fd, $v_buffer, $v_read_size); $v_size -= $v_read_size; } for ($i=0, $v_count=0; $i<sizeof($v_header_list); $i++) { if ($v_header_list[$i]['status'] == 'ok') { if (($v_result = $this->privWriteCentralFileHeader($v_header_list[$i])) != 1) { fclose($v_zip_temp_fd); $this->privCloseFd(); @unlink($v_zip_temp_name); $this->privSwapBackMagicQuotes(); return $v_result; } $v_count++; } $this->privConvertHeader2FileInfo($v_header_list[$i], $p_result_list[$i]); } $v_comment = $v_central_dir['comment']; if (isset($p_options[PCLZIP_OPT_COMMENT])) { $v_comment = $p_options[PCLZIP_OPT_COMMENT]; } if (isset($p_options[PCLZIP_OPT_ADD_COMMENT])) { $v_comment = $v_comment.$p_options[PCLZIP_OPT_ADD_COMMENT]; } if (isset($p_options[PCLZIP_OPT_PREPEND_COMMENT])) { $v_comment = $p_options[PCLZIP_OPT_PREPEND_COMMENT].$v_comment; } $v_size = @ftell($this->zip_fd)-$v_offset; if (($v_result = $this->privWriteCentralHeader($v_count+$v_central_dir['entries'], $v_size, $v_offset, $v_comment)) != 1) { unset($v_header_list); $this->privSwapBackMagicQuotes(); return $v_result; } $v_swap = $this->zip_fd; $this->zip_fd = $v_zip_temp_fd; $v_zip_temp_fd = $v_swap; $this->privCloseFd(); @fclose($v_zip_temp_fd); $this->privSwapBackMagicQuotes(); @unlink($this->zipname); PclZipUtilRename($v_zip_temp_name, $this->zipname); return $v_result; } function privOpenFd($p_mode) { $v_result=1; if ($this->zip_fd != 0) { PclZip::privErrorLog(PCLZIP_ERR_READ_OPEN_FAIL, 'Zip file \''.$this->zipname.'\' already open'); return PclZip::errorCode(); } if (($this->zip_fd = @fopen($this->zipname, $p_mode)) == 0) { PclZip::privErrorLog(PCLZIP_ERR_READ_OPEN_FAIL, 'Unable to open archive \''.$this->zipname.'\' in '.$p_mode.' mode'); return PclZip::errorCode(); } return $v_result; } function privCloseFd() { $v_result=1; if ($this->zip_fd != 0) @fclose($this->zip_fd); $this->zip_fd = 0; return $v_result; } function privAddList($p_filedescr_list, &$p_result_list, &$p_options) { $v_result=1; $v_header_list = array(); if (($v_result = $this->privAddFileList($p_filedescr_list, $v_header_list, $p_options)) != 1) { return $v_result; } $v_offset = @ftell($this->zip_fd); for ($i=0,$v_count=0; $i<sizeof($v_header_list); $i++) { if ($v_header_list[$i]['status'] == 'ok') { if (($v_result = $this->privWriteCentralFileHeader($v_header_list[$i])) != 1) { return $v_result; } $v_count++; } $this->privConvertHeader2FileInfo($v_header_list[$i], $p_result_list[$i]); } $v_comment = ''; if (isset($p_options[PCLZIP_OPT_COMMENT])) { $v_comment = $p_options[PCLZIP_OPT_COMMENT]; } $v_size = @ftell($this->zip_fd)-$v_offset; if (($v_result = $this->privWriteCentralHeader($v_count, $v_size, $v_offset, $v_comment)) != 1) { unset($v_header_list); return $v_result; } return $v_result; } function privAddFileList($p_filedescr_list, &$p_result_list, &$p_options) { $v_result=1; $v_header = array(); $v_nb = sizeof($p_result_list); for ($j=0; ($j<sizeof($p_filedescr_list)) && ($v_result==1); $j++) { $p_filedescr_list[$j]['filename'] = PclZipUtilTranslateWinPath($p_filedescr_list[$j]['filename'], false); if ($p_filedescr_list[$j]['filename'] == "") { continue; } if ( ($p_filedescr_list[$j]['type'] != 'virtual_file') && (!file_exists($p_filedescr_list[$j]['filename']))) { PclZip::privErrorLog(PCLZIP_ERR_MISSING_FILE, "File '".$p_filedescr_list[$j]['filename']."' does not exist"); return PclZip::errorCode(); } if ( ($p_filedescr_list[$j]['type'] == 'file') || ($p_filedescr_list[$j]['type'] == 'virtual_file') || ( ($p_filedescr_list[$j]['type'] == 'folder') && ( !isset($p_options[PCLZIP_OPT_REMOVE_ALL_PATH]) || !$p_options[PCLZIP_OPT_REMOVE_ALL_PATH])) ) { $v_result = $this->privAddFile($p_filedescr_list[$j], $v_header, $p_options); if ($v_result != 1) { return $v_result; } $p_result_list[$v_nb++] = $v_header; } } return $v_result; } function privAddFile($p_filedescr, &$p_header, &$p_options) { $v_result=1; $p_filename = $p_filedescr['filename']; if ($p_filename == "") { PclZip::privErrorLog(PCLZIP_ERR_INVALID_PARAMETER, "Invalid file list parameter (invalid or empty list)"); return PclZip::errorCode(); } clearstatcache(); $p_header['version'] = 20; $p_header['version_extracted'] = 10; $p_header['flag'] = 0; $p_header['compression'] = 0; $p_header['crc'] = 0; $p_header['compressed_size'] = 0; $p_header['filename_len'] = strlen($p_filename); $p_header['extra_len'] = 0; $p_header['disk'] = 0; $p_header['internal'] = 0; $p_header['offset'] = 0; $p_header['filename'] = $p_filename; $p_header['stored_filename'] = $p_filedescr['stored_filename']; $p_header['extra'] = ''; $p_header['status'] = 'ok'; $p_header['index'] = -1; if ($p_filedescr['type']=='file') { $p_header['external'] = 0x00000000; $p_header['size'] = filesize($p_filename); } else if ($p_filedescr['type']=='folder') { $p_header['external'] = 0x00000010; $p_header['mtime'] = filemtime($p_filename); $p_header['size'] = filesize($p_filename); } else if ($p_filedescr['type'] == 'virtual_file') { $p_header['external'] = 0x00000000; $p_header['size'] = strlen($p_filedescr['content']); } if (isset($p_filedescr['mtime'])) { $p_header['mtime'] = $p_filedescr['mtime']; } else if ($p_filedescr['type'] == 'virtual_file') { $p_header['mtime'] = time(); } else { $p_header['mtime'] = filemtime($p_filename); } if (isset($p_filedescr['comment'])) { $p_header['comment_len'] = strlen($p_filedescr['comment']); $p_header['comment'] = $p_filedescr['comment']; } else { $p_header['comment_len'] = 0; $p_header['comment'] = ''; } if (isset($p_options[PCLZIP_CB_PRE_ADD])) { $v_local_header = array(); $this->privConvertHeader2FileInfo($p_header, $v_local_header); $v_result = $p_options[PCLZIP_CB_PRE_ADD](PCLZIP_CB_PRE_ADD, $v_local_header); if ($v_result == 0) { $p_header['status'] = "skipped"; $v_result = 1; } if ($p_header['stored_filename'] != $v_local_header['stored_filename']) { $p_header['stored_filename'] = PclZipUtilPathReduction($v_local_header['stored_filename']); } } if ($p_header['stored_filename'] == "") { $p_header['status'] = "filtered"; } if (strlen($p_header['stored_filename']) > 0xFF) { $p_header['status'] = 'filename_too_long'; } if ($p_header['status'] == 'ok') { if ($p_filedescr['type'] == 'file') { if ( (!isset($p_options[PCLZIP_OPT_TEMP_FILE_OFF])) && (isset($p_options[PCLZIP_OPT_TEMP_FILE_ON]) || (isset($p_options[PCLZIP_OPT_TEMP_FILE_THRESHOLD]) && ($p_options[PCLZIP_OPT_TEMP_FILE_THRESHOLD] <= $p_header['size'])) ) ) { $v_result = $this->privAddFileUsingTempFile($p_filedescr, $p_header, $p_options); if ($v_result < PCLZIP_ERR_NO_ERROR) { return $v_result; } } else { if (($v_file = @fopen($p_filename, "rb")) == 0) { PclZip::privErrorLog(PCLZIP_ERR_READ_OPEN_FAIL, "Unable to open file '$p_filename' in binary read mode"); return PclZip::errorCode(); } $v_content = @fread($v_file, $p_header['size']); @fclose($v_file); $p_header['crc'] = @crc32($v_content); if ($p_options[PCLZIP_OPT_NO_COMPRESSION]) { $p_header['compressed_size'] = $p_header['size']; $p_header['compression'] = 0; } else { $v_content = @gzdeflate($v_content); $p_header['compressed_size'] = strlen($v_content); $p_header['compression'] = 8; } if (($v_result = $this->privWriteFileHeader($p_header)) != 1) { @fclose($v_file); return $v_result; } @fwrite($this->zip_fd, $v_content, $p_header['compressed_size']); } } else if ($p_filedescr['type'] == 'virtual_file') { $v_content = $p_filedescr['content']; $p_header['crc'] = @crc32($v_content); if ($p_options[PCLZIP_OPT_NO_COMPRESSION]) { $p_header['compressed_size'] = $p_header['size']; $p_header['compression'] = 0; } else { $v_content = @gzdeflate($v_content); $p_header['compressed_size'] = strlen($v_content); $p_header['compression'] = 8; } if (($v_result = $this->privWriteFileHeader($p_header)) != 1) { @fclose($v_file); return $v_result; } @fwrite($this->zip_fd, $v_content, $p_header['compressed_size']); } else if ($p_filedescr['type'] == 'folder') { if (@substr($p_header['stored_filename'], -1) != '/') { $p_header['stored_filename'] .= '/'; } $p_header['size'] = 0; $p_header['external'] = 0x00000010; if (($v_result = $this->privWriteFileHeader($p_header)) != 1) { return $v_result; } } } if (isset($p_options[PCLZIP_CB_POST_ADD])) { $v_local_header = array(); $this->privConvertHeader2FileInfo($p_header, $v_local_header); $v_result = $p_options[PCLZIP_CB_POST_ADD](PCLZIP_CB_POST_ADD, $v_local_header); if ($v_result == 0) { $v_result = 1; } } return $v_result; } function privCalculateStoredFilename(&$p_filedescr, &$p_options) { $v_result=1; $p_filename = $p_filedescr['filename']; if (isset($p_options[PCLZIP_OPT_ADD_PATH])) { $p_add_dir = $p_options[PCLZIP_OPT_ADD_PATH]; } else { $p_add_dir = ''; } if (isset($p_options[PCLZIP_OPT_REMOVE_PATH])) { $p_remove_dir = $p_options[PCLZIP_OPT_REMOVE_PATH]; } else { $p_remove_dir = ''; } if (isset($p_options[PCLZIP_OPT_REMOVE_ALL_PATH])) { $p_remove_all_dir = $p_options[PCLZIP_OPT_REMOVE_ALL_PATH]; } else { $p_remove_all_dir = 0; } if (isset($p_filedescr['new_full_name'])) { $v_stored_filename = PclZipUtilTranslateWinPath($p_filedescr['new_full_name']); } else { if (isset($p_filedescr['new_short_name'])) { $v_path_info = pathinfo($p_filename); $v_dir = ''; if ($v_path_info['dirname'] != '') { $v_dir = $v_path_info['dirname'].'/'; } $v_stored_filename = $v_dir.$p_filedescr['new_short_name']; } else { $v_stored_filename = $p_filename; } if ($p_remove_all_dir) { $v_stored_filename = basename($p_filename); } else if ($p_remove_dir != "") { if (substr($p_remove_dir, -1) != '/') $p_remove_dir .= "/"; if ( (substr($p_filename, 0, 2) == "./") || (substr($p_remove_dir, 0, 2) == "./")) { if ( (substr($p_filename, 0, 2) == "./") && (substr($p_remove_dir, 0, 2) != "./")) { $p_remove_dir = "./".$p_remove_dir; } if ( (substr($p_filename, 0, 2) != "./") && (substr($p_remove_dir, 0, 2) == "./")) { $p_remove_dir = substr($p_remove_dir, 2); } } $v_compare = PclZipUtilPathInclusion($p_remove_dir, $v_stored_filename); if ($v_compare > 0) { if ($v_compare == 2) { $v_stored_filename = ""; } else { $v_stored_filename = substr($v_stored_filename, strlen($p_remove_dir)); } } } $v_stored_filename = PclZipUtilTranslateWinPath($v_stored_filename); if ($p_add_dir != "") { if (substr($p_add_dir, -1) == "/") $v_stored_filename = $p_add_dir.$v_stored_filename; else $v_stored_filename = $p_add_dir."/".$v_stored_filename; } } $v_stored_filename = PclZipUtilPathReduction($v_stored_filename); $p_filedescr['stored_filename'] = $v_stored_filename; return $v_result; } function privWriteFileHeader(&$p_header) { $v_result=1; $p_header['offset'] = ftell($this->zip_fd); $v_date = getdate($p_header['mtime']); $v_mtime = ($v_date['hours']<<11) + ($v_date['minutes']<<5) + $v_date['seconds']/2; $v_mdate = (($v_date['year']-1980)<<9) + ($v_date['mon']<<5) + $v_date['mday']; $v_binary_data = pack("VvvvvvVVVvv", 0x04034b50, $p_header['version_extracted'], $p_header['flag'], $p_header['compression'], $v_mtime, $v_mdate, $p_header['crc'], $p_header['compressed_size'], $p_header['size'], strlen($p_header['stored_filename']), $p_header['extra_len']); fputs($this->zip_fd, $v_binary_data, 30); if (strlen($p_header['stored_filename']) != 0) { fputs($this->zip_fd, $p_header['stored_filename'], strlen($p_header['stored_filename'])); } if ($p_header['extra_len'] != 0) { fputs($this->zip_fd, $p_header['extra'], $p_header['extra_len']); } return $v_result; } function privWriteCentralFileHeader(&$p_header) { $v_result=1; $v_date = getdate($p_header['mtime']); $v_mtime = ($v_date['hours']<<11) + ($v_date['minutes']<<5) + $v_date['seconds']/2; $v_mdate = (($v_date['year']-1980)<<9) + ($v_date['mon']<<5) + $v_date['mday']; $v_binary_data = pack("VvvvvvvVVVvvvvvVV", 0x02014b50, $p_header['version'], $p_header['version_extracted'], $p_header['flag'], $p_header['compression'], $v_mtime, $v_mdate, $p_header['crc'], $p_header['compressed_size'], $p_header['size'], strlen($p_header['stored_filename']), $p_header['extra_len'], $p_header['comment_len'], $p_header['disk'], $p_header['internal'], $p_header['external'], $p_header['offset']); fputs($this->zip_fd, $v_binary_data, 46); if (strlen($p_header['stored_filename']) != 0) { fputs($this->zip_fd, $p_header['stored_filename'], strlen($p_header['stored_filename'])); } if ($p_header['extra_len'] != 0) { fputs($this->zip_fd, $p_header['extra'], $p_header['extra_len']); } if ($p_header['comment_len'] != 0) { fputs($this->zip_fd, $p_header['comment'], $p_header['comment_len']); } return $v_result; } function privWriteCentralHeader($p_nb_entries, $p_size, $p_offset, $p_comment) { $v_result=1; $v_binary_data = pack("VvvvvVVv", 0x06054b50, 0, 0, $p_nb_entries, $p_nb_entries, $p_size, $p_offset, strlen($p_comment)); fputs($this->zip_fd, $v_binary_data, 22); if (strlen($p_comment) != 0) { fputs($this->zip_fd, $p_comment, strlen($p_comment)); } return $v_result; } function privConvertHeader2FileInfo($p_header, &$p_info) { $v_result=1; $v_temp_path = PclZipUtilPathReduction($p_header['filename']); $p_info['filename'] = $v_temp_path; $v_temp_path = PclZipUtilPathReduction($p_header['stored_filename']); $p_info['stored_filename'] = $v_temp_path; $p_info['size'] = $p_header['size']; $p_info['compressed_size'] = $p_header['compressed_size']; $p_info['mtime'] = $p_header['mtime']; $p_info['comment'] = $p_header['comment']; $p_info['folder'] = (($p_header['external']&0x00000010)==0x00000010); $p_info['index'] = $p_header['index']; $p_info['status'] = $p_header['status']; $p_info['crc'] = $p_header['crc']; return $v_result; } function privReadEndCentralDir(&$p_central_dir) { $v_result=1; $v_size = filesize($this->zipname); @fseek($this->zip_fd, $v_size); if (@ftell($this->zip_fd) != $v_size) { PclZip::privErrorLog(PCLZIP_ERR_BAD_FORMAT, 'Unable to go to the end of the archive \''.$this->zipname.'\''); return PclZip::errorCode(); } $v_found = 0; if ($v_size > 26) { @fseek($this->zip_fd, $v_size-22); if (($v_pos = @ftell($this->zip_fd)) != ($v_size-22)) { PclZip::privErrorLog(PCLZIP_ERR_BAD_FORMAT, 'Unable to seek back to the middle of the archive \''.$this->zipname.'\''); return PclZip::errorCode(); } $v_binary_data = @fread($this->zip_fd, 4); $v_data = @unpack('Vid', $v_binary_data); if ($v_data['id'] == 0x06054b50) { $v_found = 1; } $v_pos = ftell($this->zip_fd); } if (!$v_found) { $v_maximum_size = 65557; if ($v_maximum_size > $v_size) $v_maximum_size = $v_size; @fseek($this->zip_fd, $v_size-$v_maximum_size); if (@ftell($this->zip_fd) != ($v_size-$v_maximum_size)) { PclZip::privErrorLog(PCLZIP_ERR_BAD_FORMAT, 'Unable to seek back to the middle of the archive \''.$this->zipname.'\''); return PclZip::errorCode(); } $v_pos = ftell($this->zip_fd); $v_bytes = 0x00000000; while ($v_pos < $v_size) { $v_byte = @fread($this->zip_fd, 1); $v_bytes = ( ($v_bytes & 0xFFFFFF) << 8) | Ord($v_byte); if ($v_bytes == 0x504b0506) { $v_pos++; break; } $v_pos++; } if ($v_pos == $v_size) { PclZip::privErrorLog(PCLZIP_ERR_BAD_FORMAT, "Unable to find End of Central Dir Record signature"); return PclZip::errorCode(); } } $v_binary_data = fread($this->zip_fd, 18); if (strlen($v_binary_data) != 18) { PclZip::privErrorLog(PCLZIP_ERR_BAD_FORMAT, "Invalid End of Central Dir Record size : ".strlen($v_binary_data)); return PclZip::errorCode(); } $v_data = unpack('vdisk/vdisk_start/vdisk_entries/ventries/Vsize/Voffset/vcomment_size', $v_binary_data); if (($v_pos + $v_data['comment_size'] + 18) != $v_size) { if (0) { PclZip::privErrorLog(PCLZIP_ERR_BAD_FORMAT, 'The central dir is not at the end of the archive.' .' Some trailing bytes exists after the archive.'); return PclZip::errorCode(); } } if ($v_data['comment_size'] != 0) { $p_central_dir['comment'] = fread($this->zip_fd, $v_data['comment_size']); } else $p_central_dir['comment'] = ''; $p_central_dir['entries'] = $v_data['entries']; $p_central_dir['disk_entries'] = $v_data['disk_entries']; $p_central_dir['offset'] = $v_data['offset']; $p_central_dir['size'] = $v_data['size']; $p_central_dir['disk'] = $v_data['disk']; $p_central_dir['disk_start'] = $v_data['disk_start']; return $v_result; } function privDeleteByRule(&$p_result_list, &$p_options) { $v_result=1; $v_list_detail = array(); if (($v_result=$this->privOpenFd('rb')) != 1) { return $v_result; } $v_central_dir = array(); if (($v_result = $this->privReadEndCentralDir($v_central_dir)) != 1) { $this->privCloseFd(); return $v_result; } @rewind($this->zip_fd); $v_pos_entry = $v_central_dir['offset']; @rewind($this->zip_fd); if (@fseek($this->zip_fd, $v_pos_entry)) { $this->privCloseFd(); PclZip::privErrorLog(PCLZIP_ERR_INVALID_ARCHIVE_ZIP, 'Invalid archive size'); return PclZip::errorCode(); } $v_header_list = array(); $j_start = 0; for ($i=0, $v_nb_extracted=0; $i<$v_central_dir['entries']; $i++) { $v_header_list[$v_nb_extracted] = array(); if (($v_result = $this->privReadCentralFileHeader($v_header_list[$v_nb_extracted])) != 1) { $this->privCloseFd(); return $v_result; } $v_header_list[$v_nb_extracted]['index'] = $i; $v_found = false; if ( (isset($p_options[PCLZIP_OPT_BY_NAME])) && ($p_options[PCLZIP_OPT_BY_NAME] != 0)) { for ($j=0; ($j<sizeof($p_options[PCLZIP_OPT_BY_NAME])) && (!$v_found); $j++) { if (substr($p_options[PCLZIP_OPT_BY_NAME][$j], -1) == "/") { if ( (strlen($v_header_list[$v_nb_extracted]['stored_filename']) > strlen($p_options[PCLZIP_OPT_BY_NAME][$j])) && (substr($v_header_list[$v_nb_extracted]['stored_filename'], 0, strlen($p_options[PCLZIP_OPT_BY_NAME][$j])) == $p_options[PCLZIP_OPT_BY_NAME][$j])) { $v_found = true; } elseif ( (($v_header_list[$v_nb_extracted]['external']&0x00000010)==0x00000010) && ($v_header_list[$v_nb_extracted]['stored_filename'].'/' == $p_options[PCLZIP_OPT_BY_NAME][$j])) { $v_found = true; } } elseif ($v_header_list[$v_nb_extracted]['stored_filename'] == $p_options[PCLZIP_OPT_BY_NAME][$j]) { $v_found = true; } } } else if ( (isset($p_options[PCLZIP_OPT_BY_PREG])) && ($p_options[PCLZIP_OPT_BY_PREG] != "")) { if (preg_match($p_options[PCLZIP_OPT_BY_PREG], $v_header_list[$v_nb_extracted]['stored_filename'])) { $v_found = true; } } else if ( (isset($p_options[PCLZIP_OPT_BY_INDEX])) && ($p_options[PCLZIP_OPT_BY_INDEX] != 0)) { for ($j=$j_start; ($j<sizeof($p_options[PCLZIP_OPT_BY_INDEX])) && (!$v_found); $j++) { if (($i>=$p_options[PCLZIP_OPT_BY_INDEX][$j]['start']) && ($i<=$p_options[PCLZIP_OPT_BY_INDEX][$j]['end'])) { $v_found = true; } if ($i>=$p_options[PCLZIP_OPT_BY_INDEX][$j]['end']) { $j_start = $j+1; } if ($p_options[PCLZIP_OPT_BY_INDEX][$j]['start']>$i) { break; } } } else { $v_found = true; } if ($v_found) { unset($v_header_list[$v_nb_extracted]); } else { $v_nb_extracted++; } } if ($v_nb_extracted > 0) { $v_zip_temp_name = PCLZIP_TEMPORARY_DIR.uniqid('pclzip-').'.tmp'; $v_temp_zip = new PclZip($v_zip_temp_name); if (($v_result = $v_temp_zip->privOpenFd('wb')) != 1) { $this->privCloseFd(); return $v_result; } for ($i=0; $i<sizeof($v_header_list); $i++) { @rewind($this->zip_fd); if (@fseek($this->zip_fd, $v_header_list[$i]['offset'])) { $this->privCloseFd(); $v_temp_zip->privCloseFd(); @unlink($v_zip_temp_name); PclZip::privErrorLog(PCLZIP_ERR_INVALID_ARCHIVE_ZIP, 'Invalid archive size'); return PclZip::errorCode(); } $v_local_header = array(); if (($v_result = $this->privReadFileHeader($v_local_header)) != 1) { $this->privCloseFd(); $v_temp_zip->privCloseFd(); @unlink($v_zip_temp_name); return $v_result; } if ($this->privCheckFileHeaders($v_local_header, $v_header_list[$i]) != 1) { } unset($v_local_header); if (($v_result = $v_temp_zip->privWriteFileHeader($v_header_list[$i])) != 1) { $this->privCloseFd(); $v_temp_zip->privCloseFd(); @unlink($v_zip_temp_name); return $v_result; } if (($v_result = PclZipUtilCopyBlock($this->zip_fd, $v_temp_zip->zip_fd, $v_header_list[$i]['compressed_size'])) != 1) { $this->privCloseFd(); $v_temp_zip->privCloseFd(); @unlink($v_zip_temp_name); return $v_result; } } $v_offset = @ftell($v_temp_zip->zip_fd); for ($i=0; $i<sizeof($v_header_list); $i++) { if (($v_result = $v_temp_zip->privWriteCentralFileHeader($v_header_list[$i])) != 1) { $v_temp_zip->privCloseFd(); $this->privCloseFd(); @unlink($v_zip_temp_name); return $v_result; } $v_temp_zip->privConvertHeader2FileInfo($v_header_list[$i], $p_result_list[$i]); } $v_comment = ''; if (isset($p_options[PCLZIP_OPT_COMMENT])) { $v_comment = $p_options[PCLZIP_OPT_COMMENT]; } $v_size = @ftell($v_temp_zip->zip_fd)-$v_offset; if (($v_result = $v_temp_zip->privWriteCentralHeader(sizeof($v_header_list), $v_size, $v_offset, $v_comment)) != 1) { unset($v_header_list); $v_temp_zip->privCloseFd(); $this->privCloseFd(); @unlink($v_zip_temp_name); return $v_result; } $v_temp_zip->privCloseFd(); $this->privCloseFd(); @unlink($this->zipname); PclZipUtilRename($v_zip_temp_name, $this->zipname); unset($v_temp_zip); } else if ($v_central_dir['entries'] != 0) { $this->privCloseFd(); if (($v_result = $this->privOpenFd('wb')) != 1) { return $v_result; } if (($v_result = $this->privWriteCentralHeader(0, 0, 0, '')) != 1) { return $v_result; } $this->privCloseFd(); } return $v_result; } function privErrorReset() { if (PCLZIP_ERROR_EXTERNAL == 1) { PclErrorReset(); } else { $this->error_code = 0; $this->error_string = ''; } } function privDisableMagicQuotes() { $v_result=1; if ( (!function_exists("get_magic_quotes_runtime")) || (!function_exists("set_magic_quotes_runtime"))) { return $v_result; } if ($this->magic_quotes_status != -1) { return $v_result; } $this->magic_quotes_status = @get_magic_quotes_runtime(); if ($this->magic_quotes_status == 1) { @set_magic_quotes_runtime(0); } return $v_result; } function privSwapBackMagicQuotes() { $v_result=1; if ( (!function_exists("get_magic_quotes_runtime")) || (!function_exists("set_magic_quotes_runtime"))) { return $v_result; } if ($this->magic_quotes_status != -1) { return $v_result; } if ($this->magic_quotes_status == 1) { @set_magic_quotes_runtime($this->magic_quotes_status); } return $v_result; } } function PclZipUtilRename($p_src, $p_dest) { $v_result = 1; if (!@rename($p_src, $p_dest)) { if (!@copy($p_src, $p_dest)) { $v_result = 0; } else if (!@unlink($p_src)) { $v_result = 0; } } return $v_result; } function PclZipUtilPathReduction($p_dir) { $v_result = ""; if ($p_dir != "") { $v_list = explode("/", $p_dir); $v_skip = 0; for ($i=sizeof($v_list)-1; $i>=0; $i--) { if ($v_list[$i] == ".") { } else if ($v_list[$i] == "..") { $v_skip++; } else if ($v_list[$i] == "") { if ($i == 0) { $v_result = "/".$v_result; if ($v_skip > 0) { $v_result = $p_dir; $v_skip = 0; } } else if ($i == (sizeof($v_list)-1)) { $v_result = $v_list[$i]; } else { } } else { if ($v_skip > 0) { $v_skip--; } else { $v_result = $v_list[$i].($i!=(sizeof($v_list)-1)?"/".$v_result:""); } } } if ($v_skip > 0) { while ($v_skip > 0) { $v_result = '../'.$v_result; $v_skip--; } } } return $v_result; } function PclZipUtilPathInclusion($p_dir, $p_path) { $v_result = 1; if ( ($p_dir == '.') || ((strlen($p_dir) >=2) && (substr($p_dir, 0, 2) == './'))) { $p_dir = PclZipUtilTranslateWinPath(getcwd(), FALSE).'/'.substr($p_dir, 1); } if ( ($p_path == '.') || ((strlen($p_path) >=2) && (substr($p_path, 0, 2) == './'))) { $p_path = PclZipUtilTranslateWinPath(getcwd(), FALSE).'/'.substr($p_path, 1); } $v_list_dir = explode("/", $p_dir); $v_list_dir_size = sizeof($v_list_dir); $v_list_path = explode("/", $p_path); $v_list_path_size = sizeof($v_list_path); $i = 0; $j = 0; while (($i < $v_list_dir_size) && ($j < $v_list_path_size) && ($v_result)) { if ($v_list_dir[$i] == '') { $i++; continue; } if ($v_list_path[$j] == '') { $j++; continue; } if (($v_list_dir[$i] != $v_list_path[$j]) && ($v_list_dir[$i] != '') && ( $v_list_path[$j] != '')) { $v_result = 0; } $i++; $j++; } if ($v_result) { while (($j < $v_list_path_size) && ($v_list_path[$j] == '')) $j++; while (($i < $v_list_dir_size) && ($v_list_dir[$i] == '')) $i++; if (($i >= $v_list_dir_size) && ($j >= $v_list_path_size)) { $v_result = 2; } else if ($i < $v_list_dir_size) { $v_result = 0; } } return $v_result; } function PclZipUtilTranslateWinPath($p_path, $p_remove_disk_letter=true) { if (stristr(php_uname(), 'windows')) { if (($p_remove_disk_letter) && (($v_position = strpos($p_path, ':')) != false)) { $p_path = substr($p_path, $v_position+1); } if ((strpos($p_path, '\\') > 0) || (substr($p_path, 0,1) == '\\')) { $p_path = strtr($p_path, '\\', '/'); } } return $p_path; } 
